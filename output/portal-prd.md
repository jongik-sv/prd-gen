# 포털 프론트엔드 설계 PRD

> 본 문서는 9개 카테고리의 설계 결정을 종합한 제품 요구사항 정의서(PRD)이다.

---

## 선택 요약

| # | 카테고리 | 선택 | 핵심 근거 |
|---|---------|------|----------|
| 1 | MF 통합 | Module Federation | Webpack 5 기반, 디펜던시 공유로 번들 최적화 |
| 2 | 보안 격리 | 동일 컨텍스트 (격리 없음) | 내부 팀 전용, 프로세스 기반 보안 |
| 3 | Design System | Design Token만 제공 | 팀 자율성 보장, 점진적 확장 가능 |
| 4 | 레이아웃 | 자유 도킹 (Docking Layout) | IDE급 패널 분할, C/S MDI 완전 재현 |
| 5 | 반응형 | 데스크톱 + 태블릿 | 현장 태블릿 지원, 모바일 제외 |
| 6 | 워크스페이스 | 미지원 | 초기 MVP, 추후 추가 |
| 7 | 알림 | 일반 알림 (P2-P3) | 알림 센터 + 배지, 긴급 알림 미포함 |
| 8 | 동기화 | BroadcastChannel만 | 같은 브라우저 탭 간 동기화 |
| 9 | App Registry | 하이브리드 (정적 + 런타임 API) | Shell 독립 배포 + 폴백 안정성 |

---

## 1. 마이크로 프론트엔드 통합: Module Federation

### 개요

Module Federation은 Webpack 5에 내장된 플러그인으로, 서로 다른 빌드 결과물(Remote) 간에 모듈을 런타임에 공유할 수 있게 한다. Shell App이 Host 역할을 하고, 각 Remote App이 자신의 모듈을 노출(expose)하면, Host가 런타임에 이를 가져와 마운트한다.

가장 큰 이점은 **디펜던시 공유**다. 모든 Remote App이 React 18을 사용한다면, React는 Shell App에서 한 번만 로딩되고 모든 Remote App이 이를 공유한다. 이로써 수백 KB의 중복 다운로드를 제거할 수 있다.

### 아키텍처

```
Shell App (Host)
├── remoteEntry.js 로딩 (CDN)
├── 공유 디펜던시 제공 (react, react-dom, react-router)
└── Remote App mount
    ├── Remote App A (remoteEntry.js → expose ./App)
    ├── Remote App B (remoteEntry.js → expose ./App)
    └── Remote App C (remoteEntry.js → expose ./App)
```

**Shell App (Host) 설정:**
Shell App의 Webpack 설정에서 ModuleFederationPlugin을 사용한다. remotes 속성에 각 Remote App의 이름과 remoteEntry.js의 CDN URL을 매핑한다. shared 속성에 react, react-dom, react-router-dom 등 공유 디펜던시를 선언하되, singleton을 true로, requiredVersion으로 허용 버전 범위를 지정한다.

**Remote App 설정:**
Remote App에서도 ModuleFederationPlugin을 사용한다. filename을 'remoteEntry.js'로, exposes에 외부 노출 모듈 경로를 지정하며, shared에 Host와 동일한 공유 디펜던시를 선언한다.

### 디펜던시 공유 전략

| 설정 | 설명 | 사용 시점 |
|------|------|----------|
| `singleton: true` | 전체 앱에서 단일 인스턴스만 허용 | React, React DOM 등 전역 상태가 있는 라이브러리 |
| `requiredVersion` | 허용 버전 범위 지정 | 메이저 버전 호환 보장 |
| `eager: true` | 초기 번들에 포함 (지연 로딩 안 함) | Shell App의 핵심 라이브러리 |
| `strictVersion: true` | 버전 불일치 시 런타임 에러 발생 | 버전 충돌을 명시적으로 감지하고 싶을 때 |

### 동적 Remote 로딩

빌드 타임에 모든 Remote를 지정하지 않고, 런타임에 App Registry로부터 Remote URL을 받아 동적으로 로딩할 수 있다. remoteEntry.js를 동적으로 삽입하고, Webpack 공유 스코프를 초기화한 뒤 컨테이너에서 모듈을 가져오는 방식이다.

### 성능 특성

| 항목 | 수치/특징 |
|------|----------|
| 초기 로딩 | 공유 디펜던시로 전체 번들 크기 30~50% 절감 |
| 앱 전환 | 같은 컨텍스트이므로 수십 ms 수준 |
| 메모리 | React 인스턴스 공유로 탭 당 메모리 사용량 적음 |
| 빌드 시간 | 각 Remote App 독립 빌드, Shell 재빌드 불필요 |

### 제약 사항

1. **빌드 도구 종속**: Webpack 5 필수. Vite 사용 팀은 vite-plugin-federation을 쓸 수 있으나 안정성이 낮음
2. **격리 부재**: 같은 window, document, global scope를 공유하므로 CSS 충돌과 전역 변수 오염 주의
3. **타입 안전성**: Remote 모듈 타입은 자동 공유되지 않으므로 별도 타입 패키지 배포 필요
4. **버전 관리**: 공유 디펜던시 버전 동기화를 위한 팀 간 협의 프로세스 필요

---

## 2. 보안 격리: 동일 컨텍스트 (격리 없음)

### 개요

모든 Remote App이 Shell App과 같은 `window`, `document`, JavaScript 힙을 공유하는 가장 단순한 통합 방식이다. 기술적 격리 장치를 두지 않는 대신, **조직적·프로세스적 보안**에 의존한다.

### 보안 확보 전략

| 계층 | 장치 | 목적 |
|------|------|------|
| **코드 리뷰** | PR 리뷰에서 보안 체크리스트 적용 | 위험한 패턴 사전 차단 |
| **정적 분석** | ESLint 보안 규칙 (no-eval, no-innerHTML 등) | 자동화된 보안 검사 |
| **의존성 검사** | npm audit, Snyk, Dependabot | 취약한 패키지 탐지 |
| **CSP 헤더** | Content-Security-Policy 적용 | XSS 실행 차단 |
| **빌드 파이프라인** | CI에서 보안 스캔 통과 필수 | 배포 전 마지막 방어선 |

### CSP(Content Security Policy) 설정

CSP 헤더 주요 정책: default-src를 'self'로 제한, script-src는 'self'와 CDN 도메인만 허용하여 인라인 스크립트 차단, connect-src는 API 및 WebSocket 서버만 허용, frame-src는 'none'으로 iframe 삽입 차단.

### CSS 충돌 방지

| 방법 | 설명 | 적용 난이도 |
|------|------|-----------|
| **CSS Modules** | 빌드 시 클래스명에 해시 접미사 추가 | 낮음 |
| **CSS-in-JS** | Styled Components, Emotion 등 런타임 스코핑 | 낮음 |
| **BEM 네이밍** | `.appA__header--active` 식의 네이밍 컨벤션 | 중간 |
| **Shadow DOM** | Web Components로 스타일 캡슐화 | 높음 |

권장: CSS Modules 또는 CSS-in-JS를 포털 전체 표준으로 지정.

### 앱 간 오류 격리

React Error Boundary 패턴으로 앱 단위 오류 격리가 가능하다. 각 Remote App을 Error Boundary로 감싸 렌더링 오류를 격리하고, 오류 시 대체 UI를 표시한다. 다만 비동기 오류, 이벤트 핸들러 오류는 `window.onerror`와 `unhandledrejection`으로 추가 처리 필요.

### 제약 사항

1. **외부 앱 불가**: 코드 리뷰 불가능한 외부/서드파티 앱은 이 방식으로 통합하면 안 됨
2. **팀 규모 제한**: 팀이 커지면 코드 리뷰만으로 모든 보안 위협 차단이 어려움
3. **책임 소재**: 한 앱 버그가 다른 앱에 영향 시 원인 추적이 어려울 수 있음
4. **규제 환경**: 금융, 의료 등에서는 기술적 격리를 요구할 수 있음

---

## 3. Design System: Design Token만 제공

### 개요

Tier 1(토큰)만 중앙에서 관리하고, Tier 2(컴포넌트)는 의도적으로 제공하지 않는 방식이다. 각 Remote App 팀은 `@portal/design-tokens` 패키지의 CSS 변수를 참조하여 색상, 폰트, 간격을 맞추되, 컴포넌트는 자체 구현하거나 서드파티 라이브러리를 사용한다.

핵심 철학: **최소한의 제약으로 최대한의 일관성**을 추구한다.

### Design Token 패키지

| 형태 | 대상 | 내용 |
|------|------|------|
| **CSS 파일** | 모든 앱 | `:root`에 CSS 변수로 정의된 전체 토큰 |
| **JSON 파일** | 빌드 도구 | 토큰의 원본 데이터 |
| **SCSS 변수** | SCSS 사용 앱 | `$color-primary: var(--color-primary)` 형태 |
| **JS 상수** | CSS-in-JS 사용 앱 | `export const colorPrimary = 'var(--color-primary)'` 형태 |

### 토큰 카테고리

| 카테고리 | 토큰 예시 | 용도 |
|---------|----------|------|
| Color | primary, secondary, error, success, warning | 색상 체계 |
| Typography | font-family, font-size (xs~xl), font-weight | 글꼴 체계 |
| Spacing | space (xs~xl) | 요소 간 간격 |
| Border | radius (sm~lg), border-width | 테두리 스타일 |
| Shadow | shadow (sm~lg) | 그림자 깊이 |
| Z-index | z-index (base, dropdown, modal, toast) | 겹침 순서 |
| Animation | duration (fast, normal, slow), easing | 트랜지션 설정 |

### 테마 전환

CSS 변수 기반이므로 `data-theme` 속성으로 Light/Dark 모드 전환이 단순하다. 토큰 값만 교체되면 각 팀 컴포넌트가 자동으로 테마에 맞춰진다.

### 서드파티 UI 라이브러리 연결

| 라이브러리 | 토큰 연결 방법 |
|-----------|---------------|
| Material UI (React) | createTheme에서 CSS 변수를 참조하는 커스텀 테마 생성 |
| Ant Design (React) | ConfigProvider의 theme 설정에서 토큰 값 매핑 |
| Element Plus (Vue) | SCSS 변수 오버라이드 또는 CSS 변수 직접 사용 |
| Vuetify (Vue) | createVuetify의 theme 설정에서 토큰 값 매핑 |

### 점진적 확장 경로

```
Phase 1: Design Token만 배포, 각 팀 자율 구현
    ↓
Phase 2: 가장 많이 중복되는 컴포넌트(버튼, 입력, 테이블)를 공통 라이브러리로 추출
    ↓
Phase 3: 전체 컴포넌트 라이브러리로 확장 (React-UI 또는 Web Components)
```

### 제약 사항

1. **UI 파편화**: 시간이 지남에 따라 앱마다 버튼 모양, 테이블 동작 등이 달라질 수 있음
2. **중복 구현**: 동일한 DataGrid, DatePicker 등을 여러 팀이 각각 구현
3. **접근성 편차**: a11y 구현 수준이 팀 역량에 의존
4. **온보딩**: 새 팀 합류 시 가이드 부족 가능

---

## 4. 레이아웃: 자유 도킹 (Docking Layout)

### 개요

패널을 제한 없이 분할하고, 가장자리에 도킹하고, 플로팅 창으로 분리하고, 원하는 위치에 병합할 수 있는 최고 수준의 유연성을 제공한다. VS Code, IntelliJ, Bloomberg Terminal에서 볼 수 있는 레이아웃 시스템이다.

### 패널 유형

| 유형 | 설명 | 예시 |
|------|------|------|
| **도킹(Docked)** | 메인 레이아웃에 고정 | 좌측 사이드바, 하단 콘솔 |
| **탭(Tabbed)** | 여러 탭을 포함하는 패널 | 중앙 편집 영역 |
| **플로팅(Floating)** | 레이아웃 위에 떠있는 독립 패널 | 속성 인스펙터 |
| **고정(Pinned)** | 접혀있다가 호버 시 펼쳐지는 패널 | 자주 참조하는 도구 |

### 도킹 동작

| 동작 | 설명 |
|------|------|
| 분할 도킹 | 기존 패널의 좌/우/상/하로 분할 배치 |
| 탭 도킹 | 기존 패널의 탭 바에 합류 |
| 가장자리 도킹 | 화면 최외곽에 전체 높이/너비 사이드 패널 배치 |
| 플로팅 | 빈 공간에 놓아 떠다니는 패널로 전환 |
| Tear-off | 브라우저 창 밖으로 드래그하여 별도 창 분리 |

### 구현 접근 (라이브러리)

| 라이브러리 | 프레임워크 | 특징 | 유지보수 |
|-----------|----------|------|---------|
| FlexLayout | React | 유연한 도킹, 탭, 플로팅 | 활발 |
| golden-layout | Vanilla JS | 고전적 도킹 레이아웃 | 유지보수 모드 |
| rc-dock | React | 도킹 + 탭 + 드래그 | 활발 |

### 메모리 관리

| 전략 | 설명 |
|------|------|
| 활성 패널 수 제한 | 동시 렌더링 패널 수를 메모리 기반 동적 제한 |
| 비가시 패널 가상화 | 보이지 않는 패널은 unmount, 표시 시 재마운트 |
| 플로팅 패널 자동 정리 | 미사용 플로팅 패널 자동 닫기 제안 |
| 메모리 모니터링 | 힙 사용량 감시, 임계값 초과 시 경고 |

### 단계적 도입

| 단계 | 기능 | 전제 조건 |
|------|------|----------|
| Phase 1 | TDI + Split View (2x2) | 기본 탭 시스템 완성 |
| Phase 2a | 분할 깊이 제한 해제 | Phase 1 안정화 |
| Phase 2b | 가장자리 도킹, 고정 패널 | Phase 2a 안정화 |
| Phase 3 | 플로팅 패널, Tear-off | Phase 2b 안정화 |

### 제약 사항

1. **구현 비용**: 전담 개발 또는 상용 라이브러리 라이선스 필요
2. **UX 복잡성**: 일반 사용자에게 과도한 자유도 → 프리셋으로 완화
3. **반응형 포기**: 사실상 데스크톱 전용, 태블릿에서는 단순 탭으로 폴백
4. **테스트 난이도**: 무한 레이아웃 조합 테스트 어려움
5. **접근성**: 드래그 앤 드롭의 키보드/스크린 리더 접근성 확보 어려움
6. **성능**: 패널 수 증가 시 DOM 노드 급증으로 렌더링 성능 저하

---

## 5. 반응형: 데스크톱 + 태블릿

### 개요

최소 뷰포트 768px 이상을 공식 지원한다. 데스크톱에서는 모든 기능을 완전하게, 태블릿에서는 핵심 기능을 터치로 조작할 수 있다. 핵심: **"데스크톱 최적, 태블릿 적응"**.

### 뷰포트별 동작

**데스크톱 (1280px+):**
- 사이드바 항상 펼침
- Split View 최대 4분할 (1920px+) 또는 3분할 (1280~1919px)
- 마우스 + 키보드 인터랙션 최적화, Pop-out 지원

**태블릿 (768~1279px):**

| 요소 | 데스크톱 | 태블릿 적응 |
|------|---------|-----------|
| 사이드바 | 항상 펼침 | 접힘 (햄버거 메뉴 토글) |
| Split View | 최대 4분할 | 최대 좌우 2분할만 |
| Pop-out | 새 브라우저 창 | 미지원 |
| 드래그 앤 드롭 | 마우스 기반 | 터치 롱프레스 + 드래그 |
| 컨텍스트 메뉴 | 우클릭 | 롱프레스 |
| 툴팁 | 마우스 호버 | 미표시 또는 탭 시 표시 |

### 패널 축소 규칙

데스크톱 4분할 → 태블릿 전환 시:
1. 활성 패널 2개만 좌우 분할 유지
2. 나머지 패널은 탭으로 전환
3. "화면 크기에 맞게 레이아웃이 조정되었습니다" 안내
4. 데스크톱 복귀 시 원래 레이아웃 복원

### 터치 최적화

| 영역 | 최적화 내용 |
|------|-----------|
| 터치 타겟 크기 | 최소 44x44px |
| 탭 바 | 탭 높이 확대, 터치 드래그 순서 변경 |
| 분할선 | 터치 영역 8px → 20px |
| 스크롤 | 관성 스크롤, 스와이프 제스처 |
| 테이블 | 터치 스크롤, 행 높이 확대 |

### 제약 사항

1. **모바일 미지원**: 스마트폰 사용 불가, 별도 모바일 앱 필요
2. **태블릿 성능**: 하드웨어 성능 한계로 대량 데이터 렌더링 시 성능 저하 가능
3. **테스트 비용**: 터치 인터랙션 + 태블릿 브라우저 호환성 테스트 추가
4. **태블릿 엣지 케이스**: 가로/세로 회전, 소프트 키보드 시 뷰포트 변화

---

## 6. 워크스페이스: 미지원

### 개요

워크스페이스 기능을 포함하지 않는다. 사용자는 매번 빈 상태에서 시작하며, 사이드바 메뉴로 필요한 탭을 직접 열고 레이아웃을 구성한다.

### 기본 동작

| 상황 | 동작 |
|------|------|
| 로그인 시 | 빈 콘텐츠 영역 (또는 기본 대시보드 1개 자동 열림) |
| 새로고침/브라우저 재시작 | 모든 탭/레이아웃 상태 소실, URL 경로의 단일 화면만 복원 |
| 다른 PC 로그인 | 완전히 새로운 시작 |

### 최소 보완책

| 보완책 | 설명 | 효과 |
|--------|------|------|
| 기본 홈 화면 | 로그인 시 대시보드 자동 열기 | 빈 화면 방지 |
| URL 기반 복원 | 활성 탭의 URL을 브라우저에 반영 | 단일 탭 복원 |
| SessionStorage | 탭 목록을 임시 보관 | 새로고침 시 탭 목록 복원 (세션 한정) |
| 즐겨찾기 메뉴 | 자주 쓰는 메뉴 등록 | 탭 열기 단축 |

### 제약 사항

1. **사용자 불만**: 복잡한 작업 환경을 매번 재구성해야 함
2. **생산성 손실**: 매일 5분 환경 구성 → 연간 20시간+ 손실
3. **온보딩 어려움**: 신규 사용자에게 어떤 화면을 열어야 하는지 안내 방법 없음
4. **추후 마이그레이션**: 나중에 워크스페이스 도입 시 기존 습관과 충돌 가능

---

## 7. 알림: 일반 알림만 (P2-P3)

### 개요

알림 센터에 알림을 쌓아두고 사용자가 확인하는 풀(Pull) 방식을 기본으로 한다. 헤더의 알림 아이콘에 미확인 건수 배지를 표시하고, 클릭 시 알림 센터 패널이 열린다.

### 알림 수준별 동작

**P2 (Normal):**

| 항목 | 동작 |
|------|------|
| 시각적 피드백 | 헤더 알림 아이콘에 숫자 배지 |
| 알림 센터 | 새 알림이 목록 상단에 추가 |
| 토스트 | 화면 우상단 자동 사라지는 토스트 (3~5초) |
| 사운드 | 없음 |
| 액션 | 클릭 시 관련 화면 이동 |

**P3 (Low):**

| 항목 | 동작 |
|------|------|
| 시각적 피드백 | 알림 센터에만 쌓임 |
| 토스트 | 없음 |
| 사운드 | 없음 |
| 액션 | 클릭 시 상세 보기 또는 관련 링크 이동 |

### 알림 센터 구성

```
┌─────────────────────────┐
│  알림 센터               │
├─────────────────────────┤
│  [전체] [미확인] [유형별] │
├─────────────────────────┤
│  ● 작업지시 #1234 완료    │
│    2분 전 | 생산관리      │
├─────────────────────────┤
│  ● 승인 요청 - 자재 발주  │
│    15분 전 | 구매팀       │
├─────────────────────────┤
│  ○ 시스템 업데이트 안내    │
│    1시간 전 | 시스템       │
├─────────────────────────┤
│  [모두 읽음으로 표시]      │
│  [알림 설정]              │
└─────────────────────────┘
```

### 알림 전달 방식

| 방식 | 실시간성 | 구현 복잡도 | 적합 |
|------|---------|-----------|------|
| 폴링 (Polling) | 주기적 (30초~1분) | 낮음 | P3 수준 |
| SSE | 준실시간 | 중간 | P2-P3 수준 |
| WebSocket | 실시간 | 높음 | P0-P3 전체 |

P2-P3만 지원하므로 **SSE 또는 폴링**으로 충분하다.

### 제약 사항

1. **긴급 대응 불가**: 설비 이상, 품질 이탈 등 즉각 대응 알림 수단 없음
2. **사용자 인지**: 토스트가 짧으면 알림을 놓칠 수 있음
3. **알림 과다**: 필터링 없이 쌓이면 중요 알림이 묻힐 수 있음
4. **오프라인**: 브라우저를 닫은 상태의 알림은 다음 접속 시에만 확인

---

## 8. 상태 동기화: BroadcastChannel만

### 개요

BroadcastChannel API는 같은 출처(origin)의 브라우저 탭/창 간에 메시지를 교환하는 웹 표준 API이다. 추가 서버 없이 브라우저가 자체 중계하므로 네트워크 지연이 없고 구현이 단순하다.

**범위**: "같은 PC, 같은 브라우저" 내의 동기화만 보장. 다른 기기/브라우저 간에는 새로고침으로 대응.

### 동기화 대상

| 이벤트 | 동작 |
|--------|------|
| 토큰 갱신 | 갱신된 토큰을 모든 탭에 전파 |
| 로그아웃 | 모든 탭이 로그인 페이지로 리다이렉트 |
| 세션 만료 | 모든 탭에 재인증 안내 |
| 알림 수신 | 모든 탭에서 배지 갱신 |
| 테마 변경 | 모든 탭에서 CSS 변수 교체 |
| 데이터 변경 | 같은 데이터를 표시 중인 탭 갱신 |

### 메시지 프로토콜

| 필드 | 설명 |
|------|------|
| type | 이벤트 유형 (AUTH_REFRESH, LOGOUT, DATA_CHANGE 등) |
| payload | 이벤트 데이터 |
| sourceTabId | 발신 탭 식별자 (자기 메시지 무시용) |
| timestamp | 발생 시각 |

### 폴백

| 방식 | 원리 | 호환성 |
|------|------|--------|
| localStorage 이벤트 | storage 이벤트 수신 | 모든 브라우저 |
| SharedWorker | 공유 웹 워커 통신 | 대부분의 브라우저 |

### 크로스 기기 한계

| 시나리오 | 문제 | 우회 |
|---------|------|------|
| PC A에서 수정 → PC B 확인 | PC B는 모름 | 새로고침 시 서버에서 로딩 |
| PC A 로그아웃 → PC B 세션 | PC B는 여전히 로그인 | 서버 측 세션 만료로 자연 로그아웃 |
| 설비 이상 알림 → 모든 기기 | BC는 같은 브라우저만 | 독립적으로 알림 API 폴링 또는 SSE |

### 제약 사항

1. **단일 브라우저 한정**: 같은 출처, 같은 브라우저 내에서만 동작
2. **직렬화**: Structured Clone Algorithm으로 직렬화, 함수/DOM 참조 전달 불가
3. **순서 비보장**: 타임스탬프 기반 정렬 필요
4. **메시지 크기**: 대량 데이터 전달 시 성능 저하 → 변경 알림만 전달

---

## 9. App Registry: 하이브리드 (정적 + 런타임 API)

### 개요

**빌드 타임 안정성**과 **런타임 유연성**을 동시에 달성한다. Shell App은 빌드 시 기본 manifest를 내장하여 항상 동작하도록 보장하고, 런타임에 Registry API를 호출하여 최신 앱 정보로 갱신한다.

Registry API가 다운되어도 빌드 내장 manifest로 동작하며, 정상이면 최신 정보를 반영하는 **이중 보험 구조**.

### 로딩 시퀀스

```
Shell App 로딩
    │
    ├── 1. 빌드 내장 manifest로 즉시 메뉴/라우팅 구성 (빠른 초기 렌더링)
    │
    ├── 2. Registry API 비동기 호출 (백그라운드)
    │   ├── 성공: API 응답으로 manifest 병합/갱신
    │   └── 실패: 빌드 내장 manifest 유지 (폴백)
    │
    └── 3. 캐싱: API 응답을 LocalStorage에 저장
        └── Stale-While-Revalidate 패턴
```

### 병합 전략

| 전략 | 동작 | 적합 상황 |
|------|------|----------|
| **API 우선 (Override)** | API 응답이 있으면 전체 교체 | API가 완전한 manifest 반환 시 |
| **병합 (Merge)** | 같은 ID는 API 우선, 없는 앱은 빌드 유지 | API가 변경분만 반환 시 |
| **추가만 (Additive)** | 빌드 유지 + API에서 새 앱만 추가 | API는 확장만 |

권장: **API 우선** 방식.

### Registry API 엔드포인트

| 엔드포인트 | 메서드 | 설명 |
|-----------|--------|------|
| /api/registry/apps | GET | 사용자 접근 가능한 전체 앱 목록 |
| /api/registry/apps/{id} | GET | 특정 앱 manifest 상세 |
| /api/registry/apps | POST | 새 앱 등록 (관리자) |
| /api/registry/apps/{id} | PUT | 앱 정보 수정 (관리자) |
| /api/registry/apps/{id} | DELETE | 앱 삭제 (관리자) |
| /api/registry/health | GET | 서비스 상태 확인 |

### 캐싱 전략

| 캐시 계층 | 위치 | 수명 | 용도 |
|----------|------|------|------|
| 빌드 내장 manifest | 코드 번들 | Shell 재빌드 시 갱신 | 최종 폴백 |
| LocalStorage | 브라우저 | 마지막 API 성공 응답 | 빠른 초기 렌더링 |
| HTTP 캐시 | 브라우저/CDN | Cache-Control 기반 | API 응답 캐싱 |
| 메모리 캐시 | Shell App | 세션 동안 | 반복 조회 방지 |

### Registry 관리 UI

| 기능 | 설명 |
|------|------|
| 앱 목록 조회 | 상태, 버전, 활성 여부 |
| 앱 등록/수정 | manifest 필드 편집 |
| 앱 활성/비활성 | 비활성화로 메뉴에서 숨기기 |
| 배포 상태 확인 | entry URL 헬스체크 |
| 이력 조회 | 등록/수정/삭제 이력 |

### 제약 사항

1. **API 가용성**: 장기간 다운 시 빌드 내장 manifest가 오래된 정보 유지
2. **일관성**: API 응답과 캐시 차이로 메뉴 깜빡임 가능
3. **보안**: Registry API 해킹 시 악의적 entry URL 배포 가능 → URL 화이트리스트 필수
4. **마이그레이션**: 정적에서 하이브리드 전환 시 기존 manifest → DB 이전 필요
5. **관리 비용**: Registry 서비스 운영 + 관리 UI 개발/유지

---

## 교차 영향 분석

선택된 9개 옵션 간의 주요 교차 영향:

### Module Federation + 동일 컨텍스트
Module Federation은 같은 JS 컨텍스트에서 실행되므로 **동일 컨텍스트 격리와 자연스럽게 호환**된다. 별도의 격리 어댑터 없이 앱 간 통신과 디펜던시 공유가 가능하다. 다만 CSS 충돌과 전역 변수 오염에 대한 프로세스적 방어가 필수다.

### 자유 도킹 + 워크스페이스 미지원 (주의)
자유 도킹은 복잡한 패널 배치를 사용자가 직접 구성하는데, 워크스페이스가 없으면 **매번 패널 배치를 처음부터 다시 해야 한다**. 이는 자유 도킹의 가치를 크게 훼손한다. SessionStorage 기반 임시 복원이라도 반드시 구현해야 하며, 워크스페이스 도입의 우선순위를 높이는 것을 강력 권장한다.

### 자유 도킹 + 데스크톱+태블릿
자유 도킹은 사실상 데스크톱 전용이므로, **태블릿에서는 단순 탭(TDI)으로 폴백**해야 한다. 데스크톱에서 구성한 도킹 레이아웃을 태블릿에서 열면 탭 기반으로 자동 변환하는 로직이 필요하다.

### Design Token + 동일 컨텍스트
동일 컨텍스트에서는 CSS가 글로벌로 공유되므로, Design Token의 CSS 변수가 모든 앱에 자동으로 적용된다. **토큰 기반 테마 전환이 가장 자연스럽게 동작**하는 조합이다. 다만 CSS Modules/CSS-in-JS로 스타일 충돌 방지가 필수.

### BroadcastChannel + 일반 알림 (P2-P3)
BroadcastChannel로 같은 브라우저 내 탭 간에 알림 배지를 동기화할 수 있다. P2-P3 수준에서는 **SSE/폴링으로 서버 알림을 수신하고, BC로 탭 간 전파**하는 구조가 적합하다.

### 하이브리드 Registry + Module Federation
Registry API가 Remote App의 remoteEntry.js URL을 제공하고, Module Federation이 이를 동적으로 로딩하는 **자연스러운 통합** 구조. Shell 재빌드 없이 Remote App을 추가/변경할 수 있다.

---

## 주요 리스크 및 완화 방안

| 리스크 | 영향 | 완화 방안 |
|--------|------|----------|
| 자유 도킹 + 워크스페이스 미지원 | 매번 레이아웃 재구성으로 사용자 불만 극대화 | SessionStorage 임시 복원 구현, 워크스페이스 우선 도입 검토 |
| 동일 컨텍스트에서 앱 오류 전파 | 한 앱 크래시로 포털 전체 영향 | Error Boundary 필수, window.onerror 전역 핸들러 |
| Token-only Design System의 UI 파편화 | 앱마다 다른 UI로 사용자 혼란 | UX 가이드라인 문서 + 정기 UX 리뷰 |
| Webpack 5 종속 | Vite 전환 시 마이그레이션 비용 | vite-plugin-federation 호환성 모니터링 |
| 태블릿에서 도킹 폴백 | UX 저하 | 태블릿 전용 단순 탭 레이아웃 별도 설계 |
