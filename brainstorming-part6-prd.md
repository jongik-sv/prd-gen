# Part 6: PRD 문서 작성 - 대화형 토론 기록

## 토의 참석자
| 분야 | 인물 |
|------|------|
| AI | Andrew Ng + Andrej Karpathy |
| DB | Martin Kleppmann |
| 아키텍처 | Martin Fowler |
| SW | Robert C. Martin (Uncle Bob) |
| PM | Kent Beck (사회자) |
| UX/보안 | Jakob Nielsen + Bruce Schneier |
| 문서화 | Donald Knuth (스타일) |

---

## 토의 1: 비전 & 목표 (6.1)

**Beck (사회자):** Part 6를 시작합니다. 지금까지 아키텍처, 인증, DB, 보안 등 기술적 토론을 충분히 했습니다. 이제 이 모든 것을 **PRD(Product Requirements Document)**로 응축할 시간입니다. 첫 번째 질문: **이 시스템은 왜 존재합니까?** 한 문장으로 정의해봅시다.

---

**Fowler:** 제가 먼저 시도하겠습니다. "분산된 사내 업무 시스템들을 하나의 포털에서 통합 접근하고, 권한과 마스터 데이터를 중앙에서 일관되게 관리하는 플랫폼." 어떻습니까?

**Uncle Bob:** 기능 설명에 가깝습니다. 비전은 **왜**에 답해야 합니다. 사용자가 이 시스템 없이 겪는 고통이 뭔지를 담아야 합니다. 현재 직원들은 업무 시스템마다 따로 로그인하고, 프로젝트마다 권한 체계가 다르고, 공통 코드가 제각각이라 데이터 정합성이 무너집니다. 이 **고통의 제거**가 비전이어야 합니다.

**Ng:** 동의합니다. AI 관점에서 보면, 데이터가 분산되어 있으면 학습도 최적화도 불가능합니다. 통합 플랫폼이 있어야 사용자 행동 패턴을 분석하고, 지능형 추천이 가능해집니다. "단일 진입점"은 기능이 아니라 **데이터 통합의 전제조건**입니다.

**Beck:** 좋습니다. 그러면 비전 스테이트먼트를 다듬어봅시다.

**Knuth:** 비전 문장은 간결하되 모호하지 않아야 합니다. 제가 정리해보겠습니다:

> **비전:** "모든 구성원이 하나의 포털에서 모든 업무 시스템에 안전하게 접근하고, 일관된 권한과 신뢰할 수 있는 마스터 데이터를 기반으로 효율적으로 협업하는 통합 업무 플랫폼"

**Nielsen:** UX 관점에서 "안전하게"와 "효율적으로"는 측정 가능해야 합니다. 비전에는 괜찮지만, 이걸 KPI로 구체화해야 합니다.

**Beck:** KPI 정의로 넘어갑시다. 각자 자기 분야에서 핵심 지표를 하나씩 제안하세요.

**Nielsen:** **사용자 경험 지표**: 포털 로그인 후 원하는 업무 시스템에 도달하기까지 걸리는 시간. 현재 각각 따로 로그인하면 평균 45초, 포털 SSO를 통하면 목표 10초 이내.

**Schneier:** **보안 지표**: 권한 위반 사고 건수. 현재 프로젝트별로 관리되어 감사 추적이 불가능한데, 포털 통합 후 모든 접근을 감사 로그로 기록하고, 비인가 접근 시도 100% 탐지를 목표로.

**Kleppmann:** **데이터 품질 지표**: 마스터 코드 불일치율. 현재 프로젝트 간 같은 코드가 다른 값으로 관리되는 비율을 측정하고, MDM Hub 통합 후 불일치율 0%를 목표로.

**Fowler:** **기술 안정성 지표**: 포털 가용성 99.9%, 평균 응답시간 200ms 이내, 배포 주기 주 1회 이상.

**Ng:** **도입 성공 지표**: 전체 프로젝트 중 포털에 온보딩된 비율. Phase 3 완료 시점에 80% 이상.

**Uncle Bob:** **코드 품질 지표**: 테스트 커버리지 80% 이상, 기술 부채 증가율 월 2% 이하. 이건 비즈니스 KPI는 아니지만, 장기적으로 시스템 생존에 직결됩니다.

**Beck:** 좋습니다. 비즈니스 목표와 기술 목표를 분리해서 정리합시다.

```
[비즈니스 목표]
B1. 업무 시스템 접근 효율화: SSO 기반 단일 로그인으로 업무 진입 시간 75% 단축
B2. 권한 관리 표준화: 프로젝트별 사일로 해소, 중앙 집중 RBAC으로 권한 사고 예방
B3. 마스터 데이터 신뢰성: 프로젝트 간 코드 불일치 제거, 단일 진실 소스(SSOT) 확보
B4. 프로젝트 온보딩 가속화: 신규 프로젝트의 포털 통합을 SDK로 표준화하여 2주 내 온보딩

[기술 목표]
T1. 포털 가용성 99.9%, 응답시간 p95 < 200ms
T2. Micro Frontend 기반 독립 배포 (프로젝트 간 의존성 제로)
T3. Zero Trust 보안 모델 구현 (모든 요청 검증)
T4. Contract-First API 개발 (OpenAPI 3.0 기반)
T5. Tracer Bullet 방식으로 Phase별 점진적 전달
```

**Karpathy:** T5에 추가로, AI 기능을 위한 **데이터 파이프라인 설계**도 기술 목표에 넣어야 합니다. Phase 4에서 AI 검색과 권한 추천을 구현하려면, Phase 1부터 사용자 행동 로그를 OpenTelemetry로 수집하는 구조가 필요합니다.

**Beck:** 좋은 지적입니다. T6으로 추가합시다.

```
T6. OpenTelemetry 기반 관측성 확보 (로그, 메트릭, 트레이스 통합 수집) - Phase 4 AI 기능의 전제조건
```

> **합의:** 비전 스테이트먼트 확정. 비즈니스 목표 4개(B1~B4) + 기술 목표 6개(T1~T6) 정의 완료. 모든 PRD 기능 요구사항은 이 목표 중 하나 이상에 매핑되어야 한다.

---

## 토의 2: 사용자 페르소나 (6.2)

**Beck (사회자):** PRD의 핵심인 **사용자 페르소나**를 정의합니다. 우리 시스템의 사용자는 크게 4종입니다. 각 페르소나를 실체감 있게 만들어봅시다. Nielsen, 리드해주세요.

---

**Nielsen:** 페르소나를 정의할 때 가장 중요한 원칙은 **구체성**입니다. "일반 사용자"라고 뭉뚱그리면 아무 설계 결정도 못 합니다. 실제 이름, 직급, 하루 일과, 좌절 포인트를 구체적으로 써야 합니다. 4종 페르소나를 하나씩 가봅시다.

### 페르소나 1: 최종 사용자 (End User)

**Nielsen:** 첫 번째 페르소나입니다.

```
이름: 김서연 (사원, 영업부)
직급: 대리 (입사 3년차)
주요 업무: 고객 주문 처리, 매출 보고서 조회, 거래처 정보 관리

일상:
- 08:30 출근, PC 부팅 후 메일 확인
- 09:00 주문관리 시스템에서 당일 주문 확인 (시스템 A)
- 10:00 거래처 정보 수정 필요 시 마스터 관리 시스템 접속 (시스템 B)
- 11:00 매출 현황 확인을 위해 BI 시스템 접속 (시스템 C)
- 오후: 각 시스템을 오가며 업무 처리

Pain Point:
- 시스템마다 ID/PW가 달라서 비밀번호를 메모장에 적어둠 (보안 위험)
- 시스템 A에서 B로 이동할 때마다 새로 로그인해야 함
- 거래처 코드가 시스템마다 달라서 수동으로 매핑해야 함
- 신규 시스템 접근 권한 요청하면 승인까지 3일 소요

핵심 니즈:
- 한 번 로그인으로 모든 시스템 접근
- 자주 쓰는 시스템 바로가기
- 알림을 한 곳에서 확인
- 검색으로 원하는 기능 빠르게 찾기

성공 기준:
- 포털 도입 후 업무 시스템 전환 시간 75% 감소
- 비밀번호 분실로 인한 IT 헬프데스크 문의 90% 감소
```

**Schneier:** 김서연 사원의 Pain Point 첫 번째가 보안의 핵심입니다. **비밀번호를 메모장에 적는 행위** 자체가 SSO 도입의 가장 강력한 정당화 근거입니다. 사람은 시스템이 많아지면 반드시 비밀번호를 재사용하거나 적어둡니다. SSO로 인증 포인트를 하나로 줄이면, 그 하나에 MFA를 적용할 수 있습니다.

**Karpathy:** AI 관점에서 김서연 사원의 행동 패턴은 매우 예측 가능합니다. 매일 비슷한 순서로 시스템을 접근합니다. Phase 4에서 "오전 9시에 주문관리 시스템을 자동으로 띄워드릴까요?"라는 AI 추천이 가능합니다.

---

### 페르소나 2: 프로젝트 관리자 (Project Manager)

**Beck:** 두 번째 페르소나는 개별 프로젝트의 관리자입니다.

```
이름: 박정우 (과장, IT기획팀)
직급: 과장 (입사 7년차)
주요 업무: 주문관리 시스템(프로젝트 A)의 운영 책임자

일상:
- 프로젝트 A의 신규 사용자 권한 부여/회수
- 프로젝트 A 전용 코드(주문 상태, 배송 유형 등) 관리
- 프로젝트 A 사용 현황 모니터링
- 팀원들의 권한 요청 승인/반려
- 분기별 권한 재검토 (Recertification)

Pain Point:
- 권한 부여 요청이 이메일로 와서 추적이 어려움
- 누가 어떤 권한을 가지고 있는지 현황 파악이 힘듬
- 코드 변경 시 다른 시스템에 미치는 영향을 모름
- 퇴직자 권한 회수가 누락되는 경우 발생

핵심 니즈:
- 자기 프로젝트의 권한 현황을 한눈에 파악
- 워크플로우 기반 권한 요청/승인 프로세스
- 코드 변경 이력 추적 및 영향도 분석
- 정기 권한 재검토 알림 및 자동화

성공 기준:
- 권한 부여 프로세스 처리 시간 2일 → 4시간 이내
- 퇴직자 권한 미회수 건수 0건
- 코드 변경 이력 100% 추적 가능
```

**Uncle Bob:** 박정우 과장의 Pain Point 네 번째가 심각합니다. 퇴직자 권한 미회수는 보안 사고의 직접적 원인이 됩니다. 이건 시스템적으로 **HR 시스템과 연동하여 자동 회수**하는 기능이 Must Have입니다.

**Schneier:** 맞습니다. 이걸 **Joiners, Movers, Leavers (JML) 프로세스**라고 합니다. 입사(Joiner), 부서이동(Mover), 퇴직(Leaver) 시 권한이 자동으로 조정되어야 합니다. 수동에 의존하면 반드시 누락됩니다.

**Kleppmann:** JML 프로세스를 구현하려면 HR 시스템에서 인사 이벤트를 실시간으로 수신해야 합니다. 이벤트 소싱 패턴으로 설계하면 이력 추적도 자동으로 됩니다.

---

### 페르소나 3: 시스템 관리자 (System Administrator)

**Nielsen:** 세 번째 페르소나입니다.

```
이름: 이승호 (차장, IT인프라팀)
직급: 차장 (입사 10년차)
주요 업무: 포털 전체의 운영 관리, 보안 정책 설정, 전사 마스터 데이터 관리

일상:
- 전사 시스템 모니터링 및 장애 대응
- 신규 프로젝트의 포털 온보딩 지원
- 보안 정책(비밀번호 규칙, 세션 정책 등) 설정 및 변경
- 전사 공통 코드(부서 코드, 직급 코드 등) 관리
- 감사 로그 조회 및 보안 감사 대응
- 분기별 전사 권한 재검토 총괄

Pain Point:
- 프로젝트별로 관리 도구가 달라서 전체 현황 파악이 불가능
- 보안 감사 시 각 시스템에서 개별적으로 로그를 추출해야 함
- 공통 코드 변경 시 모든 프로젝트에 일일이 통보해야 함
- 신규 프로젝트 온보딩에 평균 2개월 소요

핵심 니즈:
- 모든 프로젝트의 권한/사용자 현황을 통합 대시보드로 조회
- 보안 감사 로그를 한 곳에서 조회/분석/내보내기
- 공통 코드 변경을 자동 전파하고 영향받는 프로젝트에 알림
- 신규 프로젝트 온보딩 표준화 (SDK + 가이드)

성공 기준:
- 보안 감사 대응 시간 1주 → 1일 이내
- 신규 프로젝트 온보딩 2개월 → 2주 이내
- 전사 권한 현황 실시간 대시보드 제공
- 감사 로그 조회 응답시간 5초 이내
```

**Fowler:** 이승호 차장의 니즈는 명확합니다. **Platform as a Product** 관점입니다. 포털이 단순한 시스템이 아니라, 다른 프로젝트들이 소비하는 **플랫폼**으로 기능해야 합니다. 온보딩이 2개월에서 2주로 줄어야 한다는 건 SDK와 문서의 품질이 핵심이라는 뜻입니다.

---

### 페르소나 4: 개발자 (Developer)

**Uncle Bob:** 네 번째 페르소나는 제가 잘 아는 유형입니다.

```
이름: 최민지 (선임, 개발팀)
직급: 선임 개발자 (입사 5년차, React/TypeScript 전문)
주요 업무: 자기 프로젝트(물류관리 시스템)를 포털에 통합

일상:
- 물류관리 시스템의 프론트엔드 개발 (React)
- 포털 SDK를 사용하여 인증/권한/마스터데이터 연동
- CI/CD 파이프라인 관리
- 코드 리뷰 및 테스트 작성

Pain Point:
- 포털 SDK 문서가 부족하여 시행착오로 학습
- 인증 토큰 처리 로직을 직접 구현해야 해서 보안 실수 가능
- 마스터 코드를 자체 DB에 복사해서 쓰다 보니 동기화 문제 발생
- 포털 업데이트 시 하위 호환성이 깨져서 긴급 대응

핵심 니즈:
- 명확한 API 문서와 SDK (TypeScript 타입 포함)
- 인증/권한 처리가 SDK에서 자동으로 되는 구조
- 마스터 데이터를 SDK로 안전하게 조회 (캐시 포함)
- 포털 Shell과의 계약(Contract)이 버전 관리되어 하위 호환 보장

성공 기준:
- SDK 도입 후 인증/권한 관련 코드량 80% 감소
- 마스터 데이터 동기화 문제 0건
- 포털 업데이트 시 Remote App 무중단 (하위 호환 100%)
- 새 프로젝트의 포털 통합을 1인이 2주 내 완료
```

**Karpathy:** 최민지 선임의 "SDK 문서 부족" 문제는 우리가 Part 2에서 합의한 Contract-First 개발로 해결됩니다. OpenAPI 3.0 스펙에서 SDK와 문서가 자동 생성되니까요.

**Beck:** 네 페르소나를 요약합시다.

```
| 페르소나 | 이름 | 핵심 관심사 | 포털 사용 빈도 |
|----------|------|------------|---------------|
| 최종 사용자 | 김서연 (대리) | 빠른 접근, 편의성 | 매일 8시간 |
| 프로젝트 관리자 | 박정우 (과장) | 권한/코드 관리 | 매일 2시간 |
| 시스템 관리자 | 이승호 (차장) | 전체 통제, 감사 | 매일 4시간 |
| 개발자 | 최민지 (선임) | SDK, 문서, 호환성 | 개발 기간 중 상시 |
```

---

### 사용자 여정 맵

**Nielsen:** 주요 시나리오별 사용자 여정을 정리하겠습니다.

**시나리오 1: 김서연의 아침 업무 시작**

```
[1] PC 부팅 → 브라우저에서 포털 URL 접근
[2] SSO 로그인 화면 → ID/PW + MFA(선택) 입력
[3] 포털 대시보드 표시:
    - 즐겨찾기 시스템 목록
    - 최근 접근 시스템
    - 미확인 알림 배지
    - 개인화된 위젯
[4] "주문관리" 클릭 → 0.5초 내 주문관리 시스템 화면 전환
[5] 업무 처리 중 → 거래처 정보 필요 → Cmd+K로 통합 검색
[6] "거래처 관리" 검색 결과 클릭 → 마스터 관리 시스템으로 전환
[7] 거래처 정보 확인 후 → 브라우저 뒤로가기 → 주문관리로 복귀 (상태 유지)
```

**시나리오 2: 박정우의 권한 승인 처리**

```
[1] 포털 대시보드 → 알림: "김서연님이 매출보고서 접근 권한을 요청했습니다"
[2] 알림 클릭 → 권한 관리 화면으로 이동
[3] 요청 상세 확인: 요청자, 요청 권한, 사유
[4] 요청자의 현재 권한 목록 확인
[5] "승인" 버튼 클릭 → 승인 사유 입력 (선택)
[6] 즉시 적용: 김서연에게 알림 전송 + 권한 활성화
[7] 감사 로그에 자동 기록
```

**시나리오 3: 최민지의 프로젝트 온보딩**

```
[1] 포털 개발자 가이드 문서 접근
[2] SDK 설치: npm install @portal/sdk @portal/react-ui
[3] Shell Contract에 따라 manifest.json 작성
[4] SDK 초기화 코드 추가 (인증, 라우팅 훅)
[5] 개발 서버에서 Shell과 통합 테스트
[6] App Registry에 manifest 등록 (PR → 코드 리뷰 → 머지)
[7] CI/CD 파이프라인에서 자동 배포
[8] 포털에서 프로젝트 접근 가능 확인
```

> **합의:** 4종 페르소나(최종 사용자, 프로젝트 관리자, 시스템 관리자, 개발자) 상세 정의 완료. 모든 기능 요구사항은 이 페르소나의 니즈에 매핑되어야 한다. 사용자 여정 맵 3개 시나리오 정의.

---

## 토의 3: 기능 요구사항 - 포털 (6.3-1)

**Beck (사회자):** 이제 본격적으로 기능 요구사항을 정의합니다. 포털의 핵심 기능부터 시작합시다.

---

### 3-1. 대시보드

**Nielsen:** 대시보드는 사용자가 포털에 들어와서 **가장 먼저 보는 화면**입니다. Jakob의 법칙을 적용하면, 사용자는 이미 쓰고 있는 다른 포털(Google Workspace, Microsoft 365)과 비슷한 구조를 기대합니다.

대시보드에 들어가야 할 요소:

```
[대시보드 레이아웃]
┌─────────────────────────────────────────────────┐
│ [Header] 로고 | 검색바(Cmd+K) | 알림🔔 | 프로필 │
├────────┬────────────────────────────────────────┤
│        │                                        │
│ 사이드  │  ┌──────────┐ ┌──────────┐ ┌────────┐ │
│ 바     │  │ 즐겨찾기  │ │ 최근접근  │ │ 빠른   │ │
│        │  │ 앱 목록   │ │ 앱 목록  │ │ 작업   │ │
│ - 홈   │  └──────────┘ └──────────┘ └────────┘ │
│ - 프로  │                                       │
│   젝트  │  ┌──────────────────────────────────┐ │
│   목록  │  │           알림 피드              │ │
│ - 권한  │  │  - 권한 요청 승인 대기 (3건)      │ │
│   관리  │  │  - 코드 변경 알림 (2건)          │ │
│ - 마스  │  │  - 시스템 점검 공지 (1건)         │ │
│   터   │  └──────────────────────────────────┘ │
│ - 설정  │                                       │
│        │  ┌──────────────────────────────────┐ │
│        │  │        개인화 위젯 영역           │ │
│        │  │  (사용자가 추가/제거/배치 가능)    │ │
│        │  └──────────────────────────────────┘ │
└────────┴────────────────────────────────────────┘
```

**Fowler:** 대시보드의 위젯 시스템은 **각 Remote App이 위젯을 제공**하는 구조로 가야 합니다. 예를 들어, 주문관리 시스템이 "오늘의 주문 현황" 위젯을 제공하고, 사용자가 이걸 대시보드에 추가할 수 있는 구조입니다.

```typescript
// Remote App이 대시보드 위젯을 제공하는 인터페이스
interface DashboardWidget {
  id: string;
  name: string;
  description: string;
  size: 'small' | 'medium' | 'large'; // 1x1, 2x1, 2x2
  component: () => Promise<React.ComponentType<WidgetProps>>;
  refreshInterval?: number; // ms, 자동 갱신 주기
  requiredPermissions: string[];
}

interface WidgetProps {
  context: AppContext;
  config: Record<string, unknown>; // 사용자별 위젯 설정
}
```

**Uncle Bob:** 위젯 시스템은 Phase 2 이후의 기능입니다. Phase 1에서는 대시보드에 **즐겨찾기, 최근 접근, 알림 피드**만 있으면 됩니다. 위젯까지 넣으면 복잡도가 폭발합니다. **YAGNI(You Aren't Gonna Need It)** 원칙을 적용합시다.

**Beck:** 동의합니다. Phase 1 대시보드 스코프를 확정합시다.

```
[Phase 1 대시보드 - Must Have]
- 즐겨찾기 앱 목록 (사용자가 추가/제거)
- 최근 접근 앱 목록 (최근 5개, 자동)
- 알림 피드 (최신 10건)
- 빠른 작업 바로가기 (권한 요청, 코드 조회 등)

[Phase 2 이후 - Could Have]
- 개인화 위젯 시스템
- Remote App 제공 위젯
- 드래그앤드롭 레이아웃 커스터마이징
```

---

### 3-2. 프로젝트 런처 / 앱 전환

**Fowler:** 프로젝트 런처는 사용자가 **업무 시스템 간 전환**하는 핵심 경로입니다. Part 2에서 합의한 Shell App의 라우팅 흐름을 기반으로 User Story를 정의합시다.

**Beck:** User Story 형식으로 가겠습니다.

```
US-P01: 프로젝트 목록 조회
  As a 최종 사용자 (김서연),
  I want 내가 접근 가능한 프로젝트 목록을 보고 싶다,
  So that 원하는 업무 시스템에 빠르게 접근할 수 있다.

  인수 조건:
  - 사이드바에 접근 가능한 프로젝트 목록이 표시된다
  - 권한이 없는 프로젝트는 목록에 표시되지 않는다
  - 각 프로젝트에 아이콘, 이름, 설명이 표시된다
  - 프로젝트 목록은 사용 빈도 순으로 정렬된다

US-P02: 앱 전환
  As a 최종 사용자 (김서연),
  I want 현재 앱에서 다른 앱으로 빠르게 전환하고 싶다,
  So that 여러 업무를 끊김 없이 처리할 수 있다.

  인수 조건:
  - 사이드바에서 프로젝트 클릭 시 0.5초 내 화면 전환
  - 전환 중 Skeleton UI가 표시된다
  - 이전 앱의 상태가 보존되어 재진입 시 복원된다
  - URL이 변경되어 브라우저 뒤로가기/앞으로가기가 동작한다

US-P03: 즐겨찾기 관리
  As a 최종 사용자 (김서연),
  I want 자주 사용하는 앱을 즐겨찾기로 등록하고 싶다,
  So that 대시보드에서 바로 접근할 수 있다.

  인수 조건:
  - 프로젝트 목록에서 별표 아이콘으로 즐겨찾기 토글
  - 즐겨찾기는 대시보드 상단에 표시
  - 즐겨찾기 순서를 드래그앤드롭으로 변경 가능
  - 즐겨찾기는 사용자별로 저장 (서버 동기화)
```

---

### 3-3. 통합 검색 (Cmd+K)

**Karpathy:** 통합 검색은 제가 가장 관심 있는 기능입니다. **모던 앱의 핵심 UX 패턴**이 됐습니다. VS Code의 Cmd+P, Slack의 Cmd+K, Notion의 Cmd+K 모두 같은 패턴입니다.

**Nielsen:** 핵심은 **한 번의 검색으로 모든 것을 찾을 수 있어야 한다**는 것입니다. 사용자가 "거래처"를 검색하면:

```
검색 결과 분류:
1. 앱/메뉴: "거래처 관리" (마스터 관리 시스템)
2. 마스터 데이터: 거래처 코드 목록 (삼성전자, LG전자...)
3. 최근 작업: "거래처 코드 수정" (어제 작업)
4. 도움말: "거래처 등록 방법" (가이드 문서)
```

```typescript
// 통합 검색 API 인터페이스
interface SearchRequest {
  query: string;
  categories?: SearchCategory[];
  limit?: number; // 기본 10
  projectScope?: string; // 특정 프로젝트 내 검색
}

type SearchCategory = 'app' | 'menu' | 'masterData' | 'recentActivity' | 'help';

interface SearchResponse {
  results: SearchResult[];
  totalCount: number;
  responseTime: number; // ms
}

interface SearchResult {
  category: SearchCategory;
  title: string;
  description: string;
  icon: string;
  action: SearchAction;
  relevanceScore: number;
  highlights: TextHighlight[]; // 검색어 하이라이팅
}

type SearchAction =
  | { type: 'navigate'; path: string }
  | { type: 'openModal'; modalId: string; params: Record<string, unknown> }
  | { type: 'external'; url: string };
```

**Ng:** Phase 1에서는 **키워드 기반 검색**으로 충분합니다. 앱 이름, 메뉴 이름, 코드 이름을 인덱싱해서 prefix match + fuzzy match를 구현합니다. Phase 4에서 **시맨틱 검색**으로 업그레이드합니다. "매출 현황 보고 싶다"라고 입력하면 BI 시스템의 매출 보고서 메뉴를 찾아주는 것입니다.

**Uncle Bob:** Phase 1 검색의 핵심 원칙은 **응답 속도**입니다. 사용자가 타이핑하는 동안 결과가 실시간으로 나와야 합니다. 100ms 이내에 결과를 반환해야 합니다.

```
US-P04: 통합 검색
  As a 최종 사용자 (김서연),
  I want Cmd+K로 앱, 메뉴, 코드를 한 번에 검색하고 싶다,
  So that 원하는 기능을 빠르게 찾아 이동할 수 있다.

  인수 조건:
  - Cmd+K (Mac) / Ctrl+K (Windows)로 검색 모달 열기
  - 타이핑 시작 후 100ms 이내 검색 결과 표시 (디바운싱 200ms)
  - 카테고리별 그룹핑된 검색 결과 표시
  - 키보드 화살표로 결과 탐색, Enter로 이동
  - 최근 검색어 5개 표시 (검색 모달 열었을 때)
  - 검색 결과가 없을 때 "결과 없음" + 추천 검색어 표시
```

---

### 3-4. 글로벌 알림 시스템

**Beck:** 알림 시스템입니다. 이건 모든 페르소나가 사용합니다.

**Nielsen:** 알림의 **가장 큰 함정**은 너무 많이 보내서 사용자가 무시하게 되는 것입니다. Notification Fatigue는 실질적인 UX 문제입니다. 알림은 반드시 **중요도 분류**와 **사용자 제어**가 있어야 합니다.

```typescript
// 알림 타입 정의
interface Notification {
  id: string;
  type: NotificationType;
  priority: 'critical' | 'high' | 'medium' | 'low';
  title: string;
  body: string;
  source: {
    projectId: string;
    projectName: string;
  };
  action?: {
    label: string;
    path: string; // 클릭 시 이동할 경로
  };
  createdAt: string; // ISO 8601
  readAt?: string;
  expiresAt?: string; // 자동 만료
}

type NotificationType =
  | 'permission_request'    // 권한 요청 (관리자에게)
  | 'permission_granted'    // 권한 승인됨 (요청자에게)
  | 'permission_denied'     // 권한 반려됨 (요청자에게)
  | 'code_change'          // 코드 변경 알림
  | 'system_notice'        // 시스템 공지
  | 'approval_pending'     // 승인 대기
  | 'security_alert';      // 보안 경고

// 알림 설정 (사용자별)
interface NotificationPreference {
  userId: string;
  channels: {
    inApp: boolean;     // 포털 내 알림 (항상 true)
    email: boolean;     // 이메일 알림
    browser: boolean;   // 브라우저 Push 알림
  };
  // 타입별 수신 여부 설정
  typeSettings: Record<NotificationType, {
    enabled: boolean;
    minPriority: 'critical' | 'high' | 'medium' | 'low';
  }>;
  quietHours?: {
    start: string; // "22:00"
    end: string;   // "08:00"
    timezone: string;
  };
}
```

**Schneier:** `security_alert` 타입은 사용자가 끌 수 없어야 합니다. 비인가 접근 시도, 비정상 로그인 패턴 같은 보안 알림은 항상 표시되어야 합니다.

**Nielsen:** 동의합니다. **Critical 등급 알림은 사용자가 비활성화할 수 없는** 규칙을 추가합시다.

```
US-P05: 알림 확인
  As a 최종 사용자 (김서연),
  I want 모든 시스템의 알림을 포털 한 곳에서 확인하고 싶다,
  So that 중요한 알림을 놓치지 않을 수 있다.

  인수 조건:
  - 헤더의 벨 아이콘에 읽지 않은 알림 수 배지 표시
  - 클릭 시 알림 패널 열림 (최근 20건)
  - 알림 클릭 시 해당 기능 화면으로 이동
  - 전체 읽음 처리 버튼
  - "알림 설정"에서 타입별/채널별 수신 설정 가능
  - 보안 경고(critical)는 비활성화 불가

US-P06: 알림 설정 관리
  As a 최종 사용자 (김서연),
  I want 알림 수신 방법과 종류를 직접 설정하고 싶다,
  So that 불필요한 알림으로 업무가 방해받지 않도록 할 수 있다.

  인수 조건:
  - 알림 타입별 활성화/비활성화 토글
  - 채널별(인앱, 이메일, 브라우저 Push) 설정
  - 방해금지 시간대 설정
  - critical 등급은 비활성화 불가 (UI에서 토글 비활성)
```

---

### 3-5. 사용자 프로필 / 설정

**Nielsen:** 프로필과 설정은 간결하게 가겠습니다.

```
US-P07: 사용자 프로필 조회
  As a 최종 사용자 (김서연),
  I want 내 프로필 정보(이름, 부서, 역할 등)를 확인하고 싶다,
  So that 내 정보가 올바른지 확인할 수 있다.

  인수 조건:
  - 헤더의 아바타 클릭 → 프로필 드롭다운
  - 이름, 이메일, 부서, 직급, 소속 프로젝트 목록 표시
  - 내 권한 목록 조회 (프로젝트별 역할)
  - SSO 연동이므로 프로필 수정은 HR 시스템에서 (링크 제공)

US-P08: 포털 설정
  As a 최종 사용자 (김서연),
  I want 포털의 언어, 테마, 알림 설정을 변경하고 싶다,
  So that 내 선호에 맞는 환경에서 업무할 수 있다.

  인수 조건:
  - 언어 설정: 한국어/English
  - 테마 설정: 라이트/다크/시스템 연동
  - 사이드바 축소/확장 기본값 설정
  - 설정은 서버에 저장되어 기기 간 동기화
```

---

### 3-6. 즐겨찾기 / 최근 접근

**Karpathy:** 즐겨찾기와 최근 접근은 **개인화의 기본**입니다.

```
US-P09: 최근 접근 기록
  As a 최종 사용자 (김서연),
  I want 최근 접근한 앱과 메뉴를 빠르게 다시 열고 싶다,
  So that 반복 업무의 진입 시간을 줄일 수 있다.

  인수 조건:
  - 최근 접근한 앱 10개를 시간순으로 표시
  - 최근 접근한 메뉴(앱 내 경로) 5개를 표시
  - 클릭 시 해당 앱/메뉴로 즉시 이동
  - 접근 기록은 30일간 보존 후 자동 삭제
  - 특정 기록을 수동으로 삭제 가능 (개인정보)
```

> **합의:** 포털 핵심 기능 9개 User Story(US-P01~P09) 정의 완료. Phase 1 스코프: 대시보드(즐겨찾기/최근접근/알림), 프로젝트 런처, 통합 검색(Cmd+K), 글로벌 알림, 프로필/설정. 위젯 시스템은 Phase 2 이후.

---

## 토의 4: 기능 요구사항 - 권한관리 & 마스터관리 (6.3-2, 6.3-3)

**Beck (사회자):** 포털의 두 핵심 모듈인 **권한관리**와 **마스터관리**입니다. 이전 파트에서 아키텍처를 결정했으니, 이제 기능 요구사항을 User Story로 구체화합시다.

---

### 6.3-2 권한관리

**Schneier:** 권한관리는 보안의 핵심입니다. Part 3에서 합의한 **RBAC + Project Scope + OPA Policy Engine** 구조를 기반으로 기능을 정의합시다.

**Uncle Bob:** 기능을 5개 영역으로 분류합니다.

#### A. SSO 로그인

```
US-A01: SSO 로그인
  As a 최종 사용자 (김서연),
  I want 회사 계정 하나로 포털에 로그인하고 싶다,
  So that 여러 비밀번호를 관리할 필요가 없다.

  인수 조건:
  - OAuth2/OIDC 기반 SSO 로그인 화면 표시
  - 회사 IdP(Active Directory 등)와 연동
  - 로그인 성공 시 JWT Access Token (15분) + Opaque Refresh Token (7일) 발급
  - 로그인 실패 시 5회 연속 실패 → 계정 잠금 30분
  - 로그인 후 이전 접근 시도한 URL로 리다이렉트
  - 로그아웃 시 모든 세션 무효화 (Single Logout)

US-A02: MFA 인증
  As a 시스템 관리자 (이승호),
  I want 높은 권한의 사용자에게 MFA를 강제하고 싶다,
  So that 관리자 계정 탈취를 방지할 수 있다.

  인수 조건:
  - 시스템 관리자, 프로젝트 관리자 역할은 MFA 필수
  - TOTP(Google Authenticator 등) 방식 지원
  - MFA 등록 과정 (QR 코드 + 백업 코드 제공)
  - MFA 분실 시 시스템 관리자가 초기화 가능
```

#### B. RBAC + Scope 역할 관리

**Fowler:** Part 3에서 정의한 권한 모델을 기능으로 구체화합니다.

```typescript
// Part 3에서 합의된 권한 모델 (복기)
interface Role {
  id: string;
  name: string;                  // e.g., "PROJECT_ADMIN"
  scope: ProjectScope;           // 어떤 프로젝트에서 유효한지
  permissions: Permission[];     // 이 역할이 가진 권한들
  description: string;
  isSystem: boolean;             // 시스템 기본 역할 여부
}

interface ProjectScope {
  type: 'global' | 'project';   // 전체 또는 특정 프로젝트
  projectId?: string;            // project 타입일 때 프로젝트 ID
}

interface Permission {
  resource: string;              // e.g., "master_code", "user_role"
  actions: ('create' | 'read' | 'update' | 'delete')[];
  conditions?: Record<string, unknown>; // OPA 정책 조건
}
```

```
US-A03: 역할 관리 (시스템 관리자)
  As a 시스템 관리자 (이승호),
  I want 전역 역할과 프로젝트별 역할을 생성/수정/삭제하고 싶다,
  So that 조직의 권한 체계를 표준화할 수 있다.

  인수 조건:
  - 시스템 기본 역할 조회: SUPER_ADMIN, PROJECT_ADMIN, PROJECT_USER, VIEWER
  - 커스텀 역할 생성: 이름, 설명, 권한 목록, 범위(전역/프로젝트) 지정
  - 역할에 권한 추가/제거 (체크박스 매트릭스 UI)
  - 시스템 기본 역할은 수정/삭제 불가
  - 역할 삭제 시 해당 역할이 배정된 사용자 목록 경고 표시
  - 변경 이력 자동 기록

US-A04: 사용자 역할 배정 (프로젝트 관리자)
  As a 프로젝트 관리자 (박정우),
  I want 내 프로젝트 내에서 사용자에게 역할을 배정하고 싶다,
  So that 팀원들이 필요한 기능에 접근할 수 있다.

  인수 조건:
  - 자기 프로젝트의 사용자 목록 조회
  - 사용자 검색 (이름, 이메일, 사번)
  - 사용자에게 역할 배정/해제 (자기 프로젝트 범위 내)
  - 다른 프로젝트의 역할은 배정 불가 (Scope 제한)
  - 배정 즉시 적용 (캐시 무효화)
  - 변경 이력 자동 기록

US-A05: 내 권한 조회 (최종 사용자)
  As a 최종 사용자 (김서연),
  I want 내가 어떤 프로젝트에서 어떤 역할/권한을 가지고 있는지 확인하고 싶다,
  So that 접근 가능한 기능을 파악하고, 부족한 권한을 요청할 수 있다.

  인수 조건:
  - 프로필에서 "내 권한" 탭
  - 프로젝트별 배정된 역할 목록 표시
  - 각 역할의 상세 권한 펼쳐보기
  - 부족한 권한에 대해 "권한 요청" 버튼
```

#### C. 권한 위임

**Schneier:** 권한 위임은 **매우 신중하게** 설계해야 합니다. 무분별한 위임은 권한 확산(privilege escalation)의 원인이 됩니다.

```
US-A06: 권한 위임
  As a 프로젝트 관리자 (박정우),
  I want 휴가/출장 중 다른 사람에게 관리자 권한을 임시로 위임하고 싶다,
  So that 내 부재 중에도 팀 운영이 중단되지 않는다.

  인수 조건:
  - 위임 대상 사용자 선택 (같은 프로젝트 내)
  - 위임 기간 설정 (시작일~종료일, 최대 30일)
  - 위임 가능한 권한 범위 선택 (전체 또는 일부)
  - 위임 시 상위 관리자 승인 필요
  - 위임 기간 만료 시 자동 회수
  - 위임 이력 감사 로그에 기록
  - 위임받은 사용자의 모든 행위는 "위임자 대행" 표기

제약조건:
  - SUPER_ADMIN 역할은 위임 불가
  - 위임받은 권한을 다시 위임 불가 (연쇄 위임 금지)
  - 위임자가 권한을 상실하면 위임도 자동 해제
```

**Uncle Bob:** 연쇄 위임 금지 규칙이 중요합니다. A가 B에게 위임하고, B가 다시 C에게 위임하면 통제 불가능해집니다. **위임 깊이는 반드시 1단계**입니다.

#### D. 승인 워크플로우

```
US-A07: 권한 요청
  As a 최종 사용자 (김서연),
  I want 필요한 권한을 온라인으로 요청하고 싶다,
  So that 이메일이나 구두 요청 없이 체계적으로 권한을 받을 수 있다.

  인수 조건:
  - 권한 요청 양식: 대상 프로젝트, 요청 역할, 사유
  - 요청 시 프로젝트 관리자에게 자동 알림
  - 요청 상태 추적: 대기중 → 승인/반려
  - 요청 이력 조회 (내가 보낸 요청)

US-A08: 권한 승인/반려
  As a 프로젝트 관리자 (박정우),
  I want 팀원의 권한 요청을 검토하고 승인/반려하고 싶다,
  So that 적절한 권한만 부여할 수 있다.

  인수 조건:
  - 대기 중인 요청 목록 표시 (대시보드 알림 연동)
  - 요청 상세: 요청자 정보, 요청 권한, 사유, 현재 보유 권한
  - 승인 또는 반려 (반려 시 사유 필수)
  - 승인 시 즉시 권한 활성화 + 요청자 알림
  - 48시간 내 미처리 요청 → 리마인더 알림
  - 처리 이력 감사 로그에 기록
```

#### E. 감사 로그

**Schneier:** 감사 로그는 **권한 관리의 생명선**입니다. 누가, 언제, 무엇을, 왜 했는지를 빠짐없이 기록해야 합니다.

```typescript
// 감사 로그 데이터 모델
interface AuditLog {
  id: string;
  timestamp: string;         // ISO 8601
  actor: {
    userId: string;
    userName: string;
    department: string;
    ipAddress: string;
    userAgent: string;
    delegatedBy?: string;    // 위임 대행인 경우 원래 권한자
  };
  action: AuditAction;
  target: {
    type: 'user' | 'role' | 'permission' | 'delegation' | 'masterCode';
    id: string;
    name: string;
    projectId?: string;
  };
  details: Record<string, unknown>;  // 변경 전/후 값
  result: 'success' | 'failure';
  reason?: string;           // 실패 사유 또는 승인/반려 사유
}

type AuditAction =
  | 'login' | 'logout' | 'login_failed'
  | 'role_create' | 'role_update' | 'role_delete'
  | 'permission_grant' | 'permission_revoke'
  | 'permission_request' | 'permission_approve' | 'permission_deny'
  | 'delegation_create' | 'delegation_revoke'
  | 'code_create' | 'code_update' | 'code_delete' | 'code_approve';
```

```
US-A09: 감사 로그 조회
  As a 시스템 관리자 (이승호),
  I want 모든 권한 관련 활동의 감사 로그를 조회하고 싶다,
  So that 보안 감사와 이상 징후 탐지에 활용할 수 있다.

  인수 조건:
  - 필터: 기간, 사용자, 액션 유형, 프로젝트, 결과(성공/실패)
  - 검색: 사용자 이름, 대상 리소스 이름
  - 타임라인 뷰: 시간순 이벤트 스트림
  - 상세 보기: 변경 전/후 값 diff 표시
  - CSV/Excel 내보내기 (감사 보고서용)
  - 로그 보존 기간: 최소 1년 (규정 준수)
  - 조회 응답 시간: 5초 이내 (최근 3개월 데이터)
```

---

### 6.3-3 마스터관리

**Kleppmann:** 마스터 데이터 관리입니다. Part 4에서 합의한 **MDM Hub as Single Source of Truth** 구조를 기반으로 기능을 정의합니다.

#### A. 코드 CRUD

```
US-M01: 공통 코드 조회
  As a 최종 사용자 (김서연),
  I want 공통 코드(부서 코드, 직급 코드 등)를 검색하고 조회하고 싶다,
  So that 업무에 필요한 코드 값을 정확하게 사용할 수 있다.

  인수 조건:
  - 코드 그룹 목록 조회 (트리 구조)
  - 코드 그룹 내 코드 목록 조회 (테이블)
  - 코드 검색: 코드 ID, 코드명, 설명 (한글/영문)
  - 코드 상세 정보: ID, 이름, 설명, 상태(활성/비활성), 정렬순서, 상위코드, 속성값
  - 코드 간 계층 관계 표시 (트리 뷰)

US-M02: 코드 생성/수정/삭제
  As a 시스템 관리자 (이승호),
  I want 공통 코드를 생성, 수정, 삭제하고 싶다,
  So that 변화하는 업무 요건에 맞게 코드 체계를 관리할 수 있다.

  인수 조건:
  - 코드 생성: 그룹 선택 → 코드 ID(자동생성/수동), 이름, 설명, 정렬순서, 속성값 입력
  - 코드 수정: 이름, 설명, 정렬순서, 속성값, 상태 변경
  - 코드 삭제: 소프트 삭제 (상태를 '삭제됨'으로 변경)
  - 삭제 시 해당 코드를 참조하는 프로젝트 목록 경고 표시
  - 코드 ID는 생성 후 변경 불가 (불변)
  - 변경 사항은 승인 워크플로우를 통해 적용 (중요 코드)

US-M03: 프로젝트별 코드 관리
  As a 프로젝트 관리자 (박정우),
  I want 내 프로젝트 전용 코드를 관리하고 싶다,
  So that 프로젝트 특성에 맞는 코드를 운영할 수 있다.

  인수 조건:
  - 프로젝트 전용 코드 그룹 생성/수정/삭제
  - 전사 공통 코드 참조 가능 (읽기 전용)
  - 공통 코드에 프로젝트 전용 속성값 추가 가능
  - 다른 프로젝트의 코드는 접근 불가
```

#### B. 이력 관리

**Kleppmann:** 마스터 데이터의 이력 관리는 **Event Sourcing** 관점에서 설계합니다. 모든 변경은 이벤트로 기록되고, 현재 상태는 이벤트의 합산입니다.

```typescript
// 코드 변경 이력
interface CodeChangeHistory {
  id: string;
  codeGroupId: string;
  codeId: string;
  changeType: 'create' | 'update' | 'delete' | 'restore';
  changedBy: {
    userId: string;
    userName: string;
  };
  changedAt: string;  // ISO 8601
  changes: FieldChange[];
  approvedBy?: {
    userId: string;
    userName: string;
    approvedAt: string;
  };
  reason: string;  // 변경 사유 (필수)
}

interface FieldChange {
  field: string;
  oldValue: unknown;
  newValue: unknown;
}
```

```
US-M04: 코드 변경 이력 조회
  As a 시스템 관리자 (이승호),
  I want 코드의 모든 변경 이력을 추적하고 싶다,
  So that 누가 언제 왜 변경했는지 파악하고, 문제 시 원복할 수 있다.

  인수 조건:
  - 코드별 변경 이력 타임라인 표시
  - 각 변경의 변경 전/후 값 diff 표시
  - 변경자, 변경 시각, 변경 사유 표시
  - 이전 버전으로 원복 기능 (관리자 전용)
  - 원복 시 원복 사유 입력 필수
  - 이력 보존 기간: 영구 (마스터 데이터 이력은 삭제하지 않음)
```

#### C. 벌크 처리 (Excel)

**Nielsen:** 실무에서 가장 많이 요청하는 기능 중 하나가 **엑셀 업로드/다운로드**입니다. 관리자가 코드 100개를 하나씩 입력하는 건 비현실적입니다.

```
US-M05: 엑셀 다운로드
  As a 시스템 관리자 (이승호),
  I want 코드 목록을 엑셀로 다운로드하고 싶다,
  So that 오프라인에서 검토하거나 보고서에 활용할 수 있다.

  인수 조건:
  - 코드 그룹 선택 → "엑셀 다운로드" 버튼
  - 현재 필터/검색 조건이 반영된 결과 다운로드
  - 엑셀 형식: .xlsx (최대 10만 행)
  - 컬럼: 코드 ID, 코드명, 설명, 상태, 정렬순서, 상위코드, 속성값
  - 다운로드 진행률 표시 (대용량 시)

US-M06: 엑셀 업로드 (벌크 생성/수정)
  As a 시스템 관리자 (이승호),
  I want 엑셀로 코드를 대량 등록/수정하고 싶다,
  So that 대규모 코드 작업을 효율적으로 처리할 수 있다.

  인수 조건:
  - 엑셀 템플릿 다운로드 기능
  - 엑셀 업로드 → 유효성 검증 결과 미리보기
    - 성공/경고/오류 건수 표시
    - 오류 행 강조 + 오류 사유 표시
  - 오류 없는 건만 선택 적용 가능
  - 업로드 건수 제한: 1회 최대 5,000건
  - 대용량 처리 시 비동기 처리 + 완료 알림
  - 승인 워크플로우 적용 (벌크 변경은 반드시 승인 필요)
```

#### D. 승인 워크플로우

```
US-M07: 코드 변경 승인 워크플로우
  As a 시스템 관리자 (이승호),
  I want 중요 코드 변경에 대해 승인 프로세스를 적용하고 싶다,
  So that 실수나 무분별한 변경을 방지할 수 있다.

  인수 조건:
  - 코드 그룹별 승인 필요 여부 설정 (관리자가 지정)
  - 승인 필요 코드 변경 시 → "변경 요청" 상태로 저장
  - 승인자에게 알림 전송
  - 승인자 화면: 변경 전/후 diff 확인 → 승인/반려
  - 승인 시 변경 사항 즉시 적용
  - 반려 시 요청자에게 반려 사유 전달
  - 변경 요청 후 72시간 내 미처리 시 리마인더
```

#### E. 품질 대시보드

**Kleppmann:** 마스터 데이터의 **품질 관리**는 별도 대시보드가 필요합니다. 데이터 품질이 나빠지면 그 위에 쌓인 모든 비즈니스 로직이 무너집니다.

```
US-M08: 데이터 품질 대시보드
  As a 시스템 관리자 (이승호),
  I want 마스터 데이터의 품질 현황을 한눈에 파악하고 싶다,
  So that 품질 문제를 사전에 발견하고 조치할 수 있다.

  인수 조건:
  - 품질 지표 표시:
    - 전체 코드 수 / 활성 코드 수 / 비활성 코드 수
    - 최근 30일 변경 건수
    - 미사용 코드 비율 (어떤 프로젝트에서도 참조하지 않는 코드)
    - 코드명 미입력 / 설명 미입력 비율 (데이터 완전성)
    - 중복 의심 코드 목록
  - 프로젝트별 마스터 데이터 사용 현황
  - 품질 추이 그래프 (월별 트렌드)
  - 품질 규칙 위반 목록 (이름 형식, 필수값 누락 등)
```

**Ng:** Phase 4에서는 AI가 **중복 코드 자동 탐지**, **코드명 표준화 제안**, **미사용 코드 정리 추천** 같은 기능을 추가할 수 있습니다. 하지만 Phase 1에서는 이승호 차장이 수동으로 판단할 수 있는 수준의 대시보드면 충분합니다.

> **합의:** 권한관리 9개 User Story(US-A01~A09) + 마스터관리 8개 User Story(US-M01~M08) 정의 완료. 총 17개 기능 요구사항. 각 User Story는 페르소나, 기능, 인수 조건을 포함.

---

## 토의 5: 비기능 요구사항 + MoSCoW 우선순위 (6.4, 6.5)

**Beck (사회자):** 비기능 요구사항입니다. **측정 가능한 구체적 수치**로 정의해야 합니다. "빨라야 한다"는 요구사항이 아닙니다.

---

### 6.4 비기능 요구사항

#### 성능

**Fowler:** 성능 요구사항은 3가지 축으로 정의합니다.

```
[응답 시간]
- 포털 초기 로딩 (Cold Start): < 3초 (LCP 기준)
- 포털 초기 로딩 (Warm, 캐시 있음): < 1초
- 앱 전환 (Remote App 로딩): < 500ms (프리페치 시) / < 2초 (최초)
- API 응답 시간 (p50): < 100ms
- API 응답 시간 (p95): < 200ms
- API 응답 시간 (p99): < 500ms
- 통합 검색 응답: < 100ms
- 감사 로그 조회 (최근 3개월): < 5초

[동시 접속]
- 일반 동시 접속: 1,000명
- 피크 동시 접속: 5,000명
- 동시 접속 증가 시 응답 시간 저하 < 20%

[처리량]
- 마스터 코드 벌크 업로드: 5,000건/회 처리 < 30초
- 감사 로그 쓰기: 10,000 이벤트/초
- 알림 전송: 1,000건/분
```

**Karpathy:** 포털 초기 로딩 3초는 보수적입니다. Shell App만 먼저 로딩하고 Remote App은 지연 로딩하면, Shell의 First Contentful Paint를 1.5초 이내로 잡을 수 있습니다. **Core Web Vitals**를 목표로 삼읍시다.

```
[Core Web Vitals 목표]
- LCP (Largest Contentful Paint): < 2.5초 (Good)
- FID (First Input Delay): < 100ms (Good)
- CLS (Cumulative Layout Shift): < 0.1 (Good)
```

#### 가용성

**Kleppmann:** 가용성은 SLA로 정의합니다.

```
[SLA]
- 포털 가용성: 99.9% (월간 다운타임 < 43분)
- 인증 서비스 가용성: 99.95% (월간 다운타임 < 22분)
  → 인증이 죽으면 모든 서비스가 접근 불가이므로 더 높은 SLA

[RTO/RPO]
- RTO (Recovery Time Objective): < 30분
  → 장애 발생 후 서비스 복구까지 최대 30분
- RPO (Recovery Point Objective): < 5분
  → 장애 시 최대 5분의 데이터 손실 허용

[장애 대응]
- 단일 서버 장애: 자동 Failover (< 30초)
- 데이터센터 장애: DR 사이트 전환 (< 30분)
- 데이터 백업: 일 1회 전체 + 실시간 증분 (WAL 기반)
```

**Fowler:** 여기서 중요한 건 **Graceful Degradation**입니다. MDM Hub가 죽어도 2-Tier 캐시(Local 5분 + Redis 30분)에서 마스터 코드를 서빙할 수 있어야 합니다. Part 4에서 합의한 내용입니다.

#### 보안

**Schneier:** 보안 요구사항을 체계적으로 정리합니다.

```
[OWASP Top 10 대응]
- A01 Broken Access Control: RBAC + OPA 정책 엔진, 모든 API에 권한 검증
- A02 Cryptographic Failures: TLS 1.3 통신 암호화, AES-256 데이터 암호화
- A03 Injection: Parameterized Query, Input Validation, ORM 사용
- A04 Insecure Design: Threat Modeling, Security Review in SDLC
- A05 Security Misconfiguration: 보안 설정 자동화, 정기 취약점 스캔
- A06 Vulnerable Components: 의존성 자동 스캔 (Dependabot/Snyk)
- A07 Auth Failures: SSO + MFA, 계정 잠금, 세션 관리
- A08 Software/Data Integrity: CI/CD 파이프라인 무결성, SBOM 관리
- A09 Security Logging: 감사 로그 + 실시간 모니터링 (SIEM 연동)
- A10 SSRF: URL 화이트리스트, 내부 네트워크 접근 차단

[암호화]
- 전송 중: TLS 1.3 (HTTPS 필수, HSTS 적용)
- 저장 시: AES-256-GCM (민감 데이터: 비밀번호 해시, 개인정보)
- JWT 서명: RS256 (RSA 2048-bit)
- 비밀번호 해시: bcrypt (cost factor 12)

[감사 추적]
- 모든 인증/인가 이벤트 기록
- 모든 마스터 데이터 변경 기록
- 로그 위변조 방지 (Append-only, 해시 체인)
- 보존 기간: 최소 1년 (법규 준수)

[Zero Trust]
- 모든 요청에 토큰 검증 (내부 서비스 간 포함)
- 네트워크 위치 기반 신뢰 없음
- 최소 권한 원칙 (Least Privilege)
- 세션 지속 검증 (15분마다 토큰 갱신)
```

#### 확장성

**Fowler:** 확장성은 수평 확장이 핵심입니다.

```
[수평 확장]
- API 서버: 무상태(Stateless), 로드밸런서 뒤에서 수평 확장
- 인증 서비스: 독립 스케일링 (인증 트래픽은 별도 패턴)
- 마스터 데이터 서비스: Read Replica로 읽기 확장
- 알림 서비스: 메시지 큐 기반 비동기 처리

[캐시 전략] (Part 4 합의 사항)
- Local Cache (in-memory): TTL 5분, 앱 인스턴스별
- Redis Cache: TTL 30분, 공유 캐시
- 캐시 무효화: 마스터 데이터 변경 시 이벤트 기반 무효화
- Cache-Aside 패턴: 조회 시 캐시 → DB 순서, 변경 시 DB 먼저 + 캐시 무효화

[데이터베이스]
- PostgreSQL: 메인 DB (ACID 보장)
- Read Replica: 조회 부하 분산
- Connection Pooling: PgBouncer (max 200 connections per instance)
```

#### 접근성

**Nielsen:** 접근성은 법적 의무이자 UX의 기본입니다.

```
[WCAG 2.1 AA 준수]
- 키보드 탐색: 모든 기능을 키보드만으로 사용 가능
- 스크린 리더: ARIA 레이블, 의미 있는 HTML 구조
- 색상 대비: 텍스트/배경 대비 4.5:1 이상
- 폰트 크기: 최소 14px, 사용자 조정 가능
- 포커스 인디케이터: 명확한 시각적 포커스 표시
- 오류 메시지: 색상만으로 구분하지 않음 (아이콘 + 텍스트)
- 반응형 디자인: 1024px ~ 1920px 지원 (모바일은 v1에서 제외)
```

---

### 6.5 MoSCoW 우선순위

**Beck:** 모든 기능을 한꺼번에 만들 수 없으니, MoSCoW 분류를 합시다. 각자 의견을 내고, 합의로 결정합니다.

**Uncle Bob:** MoSCoW의 핵심은 **Must Have를 최소화**하는 것입니다. Must Have가 전체의 60%를 넘으면 MoSCoW가 아니라 "다 해야 한다"와 같습니다.

```
┌─────────────────────────────────────────────────────────────────┐
│ MUST HAVE (v1 필수 - 이것 없으면 시스템이 성립하지 않음)          │
├─────────────────────────────────────────────────────────────────┤
│ [인증/인가]                                                      │
│  • SSO 로그인/로그아웃 (US-A01)                                  │
│  • 기본 RBAC 역할 관리 - 시스템 기본 역할 4종 (US-A03)           │
│  • 사용자 역할 배정 (US-A04)                                     │
│  • 내 권한 조회 (US-A05)                                        │
│                                                                  │
│ [포털]                                                           │
│  • 대시보드 - 즐겨찾기/최근접근/알림 (US-P01, P03, P09)          │
│  • 프로젝트 런처 / 앱 전환 (US-P02)                              │
│  • 사용자 프로필 (US-P07)                                        │
│                                                                  │
│ [마스터관리]                                                      │
│  • 공통 코드 CRUD (US-M01, M02)                                  │
│  • 프로젝트별 코드 관리 (US-M03)                                 │
│                                                                  │
│ [기술 기반]                                                       │
│  • Shell App + Module Federation 기반 Remote App 통합             │
│  • App Registry (하이브리드 manifest)                             │
│  • 2-Tier 캐시 (Local + Redis)                                   │
│  • 기본 감사 로그 (인증 이벤트)                                   │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ SHOULD HAVE (v1에 가능하면 포함, 없어도 최소 기능은 동작)         │
├─────────────────────────────────────────────────────────────────┤
│  • MFA 인증 (US-A02)                                             │
│  • 권한 위임 (US-A06)                                            │
│  • 권한 요청/승인 워크플로우 (US-A07, A08)                        │
│  • 통합 검색 Cmd+K (US-P04)                                      │
│  • 글로벌 알림 시스템 (US-P05, P06)                               │
│  • 마스터 코드 변경 이력 관리 (US-M04)                            │
│  • 코드 변경 승인 워크플로우 (US-M07)                             │
│  • 감사 로그 상세 조회/내보내기 (US-A09)                          │
│  • 포털 설정 - 테마/언어 (US-P08)                                 │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ COULD HAVE (있으면 좋지만, v1에서 빠져도 무방)                    │
├─────────────────────────────────────────────────────────────────┤
│  • 엑셀 벌크 업로드/다운로드 (US-M05, M06)                       │
│  • 데이터 품질 대시보드 (US-M08)                                 │
│  • AI 기반 통합 검색 (시맨틱 검색)                                │
│  • 권한 추천 (사용자 패턴 기반)                                   │
│  • 대시보드 개인화 위젯 시스템                                    │
│  • 앱 전환 시 AI 프리페치 예측                                    │
│  • JML(입사/이동/퇴직) 자동 권한 조정                             │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ WON'T HAVE (v1에서 명시적으로 제외)                               │
├─────────────────────────────────────────────────────────────────┤
│  • 크로스 프로젝트 워크플로우 (프로젝트 A→B 연계 프로세스)        │
│  • 고급 분석 (사용자 행동 분석 대시보드, BI 연동)                 │
│  • 모바일 네이티브 앱                                             │
│  • 외부 서드파티 앱 마켓플레이스                                   │
│  • 멀티 테넌트 (다른 조직에 서비스 제공)                          │
│  • 실시간 협업 기능 (공동 편집 등)                                │
└─────────────────────────────────────────────────────────────────┘
```

**Ng:** Must Have에 AI 기능이 없는 게 맞습니다. AI는 기반 데이터가 쌓인 후에야 의미가 있습니다. 다만, **OpenTelemetry로 사용자 행동 데이터를 수집하는 인프라**는 Must Have에 포함되어야 합니다. 나중에 AI를 붙이려면 데이터가 있어야 합니다.

**Beck:** 좋은 지적입니다. Must Have의 기술 기반에 "OpenTelemetry 기반 로그/메트릭/트레이스 수집 인프라"를 추가합시다.

**Schneier:** MFA를 Should Have로 분류한 건 재고해야 합니다. 시스템 관리자 계정이 탈취되면 전체 시스템이 위험합니다. 최소한 **SUPER_ADMIN 역할에 대한 MFA는 Must Have**입니다.

**Beck:** 합리적입니다. MFA를 둘로 나눕시다: SUPER_ADMIN MFA는 Must Have, 그 외 역할 MFA 확대는 Should Have.

> **합의:** MoSCoW 분류 확정. Must Have 12개 기능 + 기술 기반, Should Have 9개, Could Have 7개, Won't Have 6개. SUPER_ADMIN MFA는 Must Have로 승격. OpenTelemetry 수집 인프라 Must Have 추가.

---

## 토의 6: 릴리즈 로드맵 (6.6)

**Beck (사회자):** 마지막 토의입니다. **언제 뭘 만들 것인가**. Part 1에서 합의한 **Tracer Bullet** 방식을 기반으로 Phase별 계획을 세웁시다.

---

**Fowler:** Tracer Bullet의 핵심을 다시 짚겠습니다. Phase 0에서 **가장 위험한 기술적 경로를 끝까지 관통**합니다. "Shell App → SSO 로그인 → Remote App 로딩 → 마스터 코드 조회"까지 전체 경로가 동작하는 것을 Phase 0에서 증명합니다. 기능이 부족해도, 빈약해도 괜찮습니다. **경로가 동작하는 것**이 핵심입니다.

**Uncle Bob:** 이것이 **Big Bang Integration**과 정반대의 접근입니다. 각 모듈을 독립적으로 완벽하게 만들고 마지막에 합치는 게 아니라, 처음부터 끝까지 연결된 가는 선을 먼저 긋고, 그 선을 점점 굵게 만드는 것입니다.

---

### Phase 0: 파일럿 프로젝트 선정 + Tracer Bullet (4주)

**Beck:** Phase 0의 핵심 결정: **어떤 프로젝트를 파일럿으로 선정하는가?**

**Fowler:** 파일럿 프로젝트 선정 기준:

```
[파일럿 프로젝트 선정 기준]
1. 기술 스택: React/TypeScript (Module Federation과 호환성 최고)
2. 팀 역량: 변화에 적극적인 팀 (Early Adopter)
3. 복잡도: 중간 수준 (너무 단순하면 검증 의미 없음, 너무 복잡하면 리스크)
4. 비즈니스 임팩트: 사용자 수 50~200명 수준
5. 권한 요건: RBAC이 필요한 프로젝트 (권한 모듈 검증)
6. 마스터 데이터 의존성: 공통 코드를 사용하는 프로젝트
```

```
[Phase 0 목표: Tracer Bullet]
기간: 4주
인력: 풀타임 3~4명 (프론트 2, 백엔드 1, 인프라 1)

구현 범위 (최소한):
- Shell App 뼈대: Header + Sidebar + Content Area
- SSO 로그인: IdP 연동, JWT 발급, 세션 관리
- Remote App 로딩: Module Federation으로 파일럿 앱 1개 로딩
- 마스터 코드 조회: API → DB → 응답 (1개 코드 그룹)
- 기본 RBAC: 로그인한 사용자의 역할 확인 → 메뉴 필터링
- 인프라: CI/CD 파이프라인, Docker 컨테이너, 스테이징 환경

하지 않는 것:
- UI 디자인 (기본 UI만, Design Token 미적용)
- 알림, 검색, 대시보드 위젯
- 관리자 화면
- 성능 최적화
```

**Karpathy:** Phase 0에서 **OpenTelemetry 수집도 연결**해야 합니다. 앞서 합의한 대로, AI 기능의 전제조건인 데이터 수집을 처음부터 시작해야 합니다. 기본 트레이스 수집만이라도요.

```
[Phase 0 Go/No-Go 기준]
✅ 사용자가 SSO로 로그인하여 Shell에 진입할 수 있다
✅ Shell에서 파일럿 Remote App으로 전환할 수 있다
✅ Remote App에서 마스터 코드를 조회할 수 있다
✅ 권한이 없는 메뉴는 표시되지 않는다
✅ CI/CD 파이프라인에서 Shell과 Remote App이 독립 배포된다
✅ 전체 경로의 응답시간이 3초 이내다
❌ 위 기준 중 하나라도 실패하면 Phase 1 진입 불가
```

---

### Phase 1: SSO + 포털 Shell + 파일럿 통합 (8주)

```
[Phase 1 목표]
기간: 8주
인력: 풀타임 6~8명

구현 범위:
- SSO 완성: 로그인/로그아웃, 토큰 갱신, Single Logout, SUPER_ADMIN MFA
- Shell App 완성:
  - Design Token 적용 (Tier 1: CSS 변수)
  - Header: 로고, 사용자 프로필, 알림 아이콘 (기본)
  - Sidebar: 프로젝트 메뉴 (App Registry 연동)
  - Content Area: Remote App 마운트/언마운트
  - Skeleton UI + 앱 상태 캐싱
  - 기본 대시보드 (즐겨찾기, 최근 접근)
- App Registry Service: manifest 관리 API
- 파일럿 프로젝트 완전 통합: SDK 사용하여 인증/라우팅/마스터 코드 연동
- SDK v0.1: @portal/sdk (auth, navigation, events)
- 기본 RBAC: 시스템 기본 역할 4종, 사용자 역할 배정
- 마스터 코드 CRUD: 관리자 화면 (기본 UI)
- 2-Tier 캐시: Local + Redis
- OpenTelemetry: 기본 트레이스/메트릭 수집

하지 않는 것:
- 통합 검색 (Cmd+K)
- 권한 위임
- 승인 워크플로우
- 엑셀 벌크 처리
- 글로벌 알림 (기본 인앱 알림만)
```

```
[Phase 1 Go/No-Go 기준]
✅ 파일럿 프로젝트 사용자 50명이 포털을 통해 업무 수행 가능
✅ SSO 로그인 성공률 99.5% 이상
✅ 앱 전환 시간 p95 < 2초
✅ 마스터 코드 CRUD가 관리자 화면에서 정상 동작
✅ RBAC으로 권한별 메뉴 접근 제어 동작
✅ SDK 문서가 다른 팀이 보고 따라할 수 있는 수준
✅ 포털 가용성 99.5% 이상 (Phase 1은 99.9% 미요구)
❌ 사용자 피드백에서 Critical 이슈가 미해결 상태이면 Phase 2 진입 불가
```

---

### Phase 2: RBAC 권한관리 + 마스터 코드 관리 강화 (8주)

```
[Phase 2 목표]
기간: 8주
인력: 풀타임 8~10명

구현 범위:
- 권한 관리 강화:
  - 커스텀 역할 생성/수정/삭제
  - 권한 요청/승인 워크플로우
  - MFA 확대 (모든 관리자 역할)
  - 감사 로그 상세 조회/필터/내보내기
- 마스터 관리 강화:
  - 코드 변경 이력 관리 (타임라인, diff)
  - 코드 변경 승인 워크플로우
  - 엑셀 다운로드/업로드 (벌크 처리)
  - 프로젝트별 코드 관리 UI 개선
- 포털 강화:
  - 통합 검색 (Cmd+K) - 키워드 기반
  - 글로벌 알림 시스템 (인앱 + 이메일)
  - 알림 설정 관리
  - 포털 설정 (테마, 언어)
- SDK v1.0: @portal/sdk 정식 릴리즈 (하위 호환 보장 시작)
- 추가 프로젝트 1~2개 온보딩 준비

하지 않는 것:
- 권한 위임
- 데이터 품질 대시보드
- AI 기능
- JML 자동화
```

```
[Phase 2 Go/No-Go 기준]
✅ 권한 요청 → 승인 → 적용 전체 워크플로우가 정상 동작
✅ 감사 로그에서 최근 3개월 데이터 5초 내 조회
✅ 엑셀 5,000건 업로드가 30초 내 완료
✅ 통합 검색 응답시간 100ms 이내
✅ 알림 시스템으로 권한 승인/반려 결과가 실시간 전달
✅ SDK v1.0이 하위 호환 테스트를 통과
✅ 포털 가용성 99.9% 달성
❌ 보안 감사에서 OWASP Top 10 관련 Critical 취약점이 있으면 Phase 3 진입 불가
```

---

### Phase 3: 추가 프로젝트 온보딩 + SDK 안정화 (10주)

```
[Phase 3 목표]
기간: 10주
인력: 풀타임 8~10명 + 온보딩 대상 프로젝트팀 참여

구현 범위:
- 추가 프로젝트 3~5개 온보딩:
  - 각 프로젝트별 manifest 작성 + 통합 테스트
  - 다양한 프레임워크 검증 (React 외 Vue/Angular)
  - 온보딩 과정에서 SDK 피드백 반영
- SDK 안정화:
  - @portal/sdk v1.x (버그 픽스, 성능 개선)
  - @portal/react-ui 컴포넌트 라이브러리 v1.0
  - @portal/vue-ui (Vue 프로젝트가 있는 경우)
  - 개발자 가이드 문서 완성
- 권한 위임 기능 (US-A06)
- 데이터 품질 대시보드 기본 (US-M08)
- JML 자동화 (HR 시스템 연동)
- 성능 최적화:
  - 프리페칭 전략 고도화 (사용 빈도 기반)
  - 번들 사이즈 최적화
  - DB 쿼리 최적화
- 모니터링 고도화:
  - 대시보드 (Grafana)
  - 알림 룰 (PagerDuty/Slack 연동)

하지 않는 것:
- AI 기능
- 크로스 프로젝트 워크플로우
- 모바일 앱
```

```
[Phase 3 Go/No-Go 기준]
✅ 전체 프로젝트의 80% 이상이 포털에 온보딩 완료
✅ 온보딩 소요 시간이 프로젝트당 2주 이내
✅ SDK 관련 Critical 버그 0건
✅ 포털 동시 접속 1,000명에서 p95 응답시간 < 200ms
✅ 권한 위임이 정상 동작 (위임 → 자동 회수 포함)
✅ JML 프로세스로 퇴직자 권한 자동 회수 검증 완료
❌ 프로젝트팀의 SDK 만족도(설문) 4.0/5.0 미만이면 Phase 4 진입 전 개선 필요
```

---

### Phase 4: AI 기능 + 고급 권한 + 데이터 품질 (12주)

**Ng:** 이제 제 차례입니다. Phase 4에서 AI 기능을 본격적으로 도입합니다. Phase 0~3에서 수집한 데이터가 최소 6개월치는 있어야 의미 있는 AI 기능을 만들 수 있습니다.

```
[Phase 4 목표]
기간: 12주
인력: 풀타임 10~12명 (AI 엔지니어 2명 추가)

구현 범위:
- AI 기반 통합 검색 (시맨틱 검색):
  - 자연어 쿼리 → 의도 파악 → 관련 앱/메뉴/코드 추천
  - Embedding 기반 유사도 검색
  - 검색 결과 개인화 (사용 패턴 기반)
- AI 권한 추천:
  - 같은 부서/직급의 사용자가 가진 권한 기반 추천
  - 신규 입사자에게 권한 세트 자동 제안
  - 미사용 권한 회수 제안
- 마스터 데이터 품질 자동화:
  - 중복 코드 자동 탐지
  - 코드명 표준화 제안
  - 미사용 코드 정리 추천
  - 데이터 품질 점수 자동 산출
- 고급 권한 기능:
  - Attribute-Based Access Control (ABAC) 요소 도입
  - 시간 기반 권한 (업무 시간에만 접근 가능)
  - 위치 기반 권한 (사내 네트워크에서만 접근 가능)
- 대시보드 고도화:
  - 개인화 위젯 시스템
  - Remote App 제공 위젯
  - AI 기반 프리페치 예측
```

**Karpathy:** AI 기능 구현 시 주의할 점이 있습니다. **AI 추천은 반드시 사람이 최종 확인**해야 합니다. AI가 권한을 자동으로 부여하면 안 됩니다. "이 권한이 필요할 것 같습니다. 요청하시겠습니까?"까지만이고, 실제 부여는 기존 승인 워크플로우를 따라야 합니다.

**Schneier:** 절대적으로 동의합니다. **AI가 보안 결정을 자동으로 내리는 것은 Phase 4에서도 금지**입니다. AI는 추천까지, 결정은 사람이 합니다.

```
[Phase 4 Go/No-Go 기준]
✅ 시맨틱 검색 정확도(MRR@5) 0.7 이상
✅ AI 권한 추천 수락율 40% 이상 (사용자가 실제로 유용하다고 판단)
✅ 중복 코드 탐지 정밀도(Precision) 80% 이상
✅ 모든 AI 추천에 "사람 확인" 단계 포함 검증
✅ 전체 시스템 가용성 99.9% 유지 (AI 기능 추가로 인한 저하 없음)
```

---

### 전체 로드맵 요약

```
[타임라인]
Phase 0 (4주)  ████
Phase 1 (8주)  ████████
Phase 2 (8주)  ████████
Phase 3 (10주) ██████████
Phase 4 (12주) ████████████
               ─────────────────────────────
               0    8    16   24   32   42주 (약 10개월)

[누적 기능]
Phase 0: Tracer Bullet (SSO → Shell → Remote App → 마스터코드)
Phase 1: + 대시보드, 기본 RBAC, 코드 CRUD, SDK v0.1, 파일럿 1개
Phase 2: + 검색, 알림, 워크플로우, 감사로그, 벌크처리, SDK v1.0
Phase 3: + 5개 프로젝트 온보딩, 권한 위임, JML, 품질 대시보드
Phase 4: + AI 검색, AI 권한 추천, 데이터 품질 자동화, ABAC, 위젯
```

---

### 리스크 관리

**Beck:** 마지막으로 리스크를 정리합시다.

**Fowler:** 각 Phase별 핵심 리스크와 대응 방안입니다.

```
[리스크 매트릭스]
| # | 리스크 | 영향도 | 발생확률 | Phase | 대응 방안 |
|----|--------|--------|---------|-------|----------|
| R1 | IdP(SSO) 연동 지연 | 높음 | 중간 | 0-1 | Mock IdP로 개발, 실제 연동은 병렬 진행 |
| R2 | Module Federation 호환성 문제 | 높음 | 중간 | 0 | Phase 0 Tracer Bullet에서 조기 검증 |
| R3 | 프로젝트팀 온보딩 저항 | 중간 | 높음 | 3 | 파일럿 성공 사례로 설득, SDK DX 극대화 |
| R4 | 마스터 데이터 마이그레이션 | 높음 | 중간 | 1-2 | 점진적 마이그레이션, 양방향 동기화 과도기 |
| R5 | 성능 목표 미달 | 중간 | 중간 | 2-3 | 성능 테스트 자동화, Phase별 벤치마크 |
| R6 | AI 기능 정확도 부족 | 낮음 | 중간 | 4 | Phase 4는 충분한 데이터 축적 후 시작 |
| R7 | 보안 취약점 발견 | 높음 | 낮음 | 전체 | 정기 보안 감사, 자동 취약점 스캔, Bug Bounty |
| R8 | 핵심 인력 이탈 | 높음 | 낮음 | 전체 | 문서화 철저, 페어 프로그래밍, 지식 공유 세션 |
```

**Uncle Bob:** R8(핵심 인력 이탈)은 모든 프로젝트의 숨은 리스크입니다. 이걸 완화하는 가장 좋은 방법은 **코드가 곧 문서**가 되도록 Clean Code를 작성하고, **한 사람만 아는 영역**이 없도록 코드 리뷰와 페어 프로그래밍을 하는 것입니다.

**Kleppmann:** R4(마스터 데이터 마이그레이션)가 가장 과소평가되기 쉬운 리스크입니다. 기존 프로젝트들이 각자 관리하던 코드를 MDM Hub로 통합하는 과정에서 **코드 매핑, 데이터 정제, 이중 운영 기간**이 필요합니다. 최소 Phase 1~2에 걸쳐 점진적으로 해야 합니다.

**Ng:** R6(AI 정확도)은 Phase 4에서만 해당되고, 충분한 데이터가 있으면 중간 확률도 낮아집니다. 핵심은 Phase 0부터 데이터를 수집하는 것이고, 우리는 이미 합의했습니다.

> **최종 합의:** Tracer Bullet 기반 5단계 로드맵(Phase 0~4, 총 42주) 확정. 각 Phase에 Go/No-Go 기준을 명확히 정의하여 리스크를 통제. 8개 핵심 리스크 식별 및 대응 방안 수립. AI는 추천까지만, 보안 결정은 반드시 사람이 한다는 원칙 재확인.

---

## PRD 핵심 결정 사항 요약

| # | 영역 | 결정 사항 | 상세 |
|---|------|----------|------|
| 1 | 비전 | 비전 스테이트먼트 | "모든 구성원이 하나의 포털에서 모든 업무 시스템에 안전하게 접근하고, 일관된 권한과 신뢰할 수 있는 마스터 데이터로 효율적으로 협업하는 통합 업무 플랫폼" |
| 2 | 목표 | 비즈니스 목표 4개 | B1 접근 효율화, B2 권한 표준화, B3 마스터 SSOT, B4 온보딩 가속화 |
| 3 | 목표 | 기술 목표 6개 | T1 가용성 99.9%, T2 독립 배포, T3 Zero Trust, T4 Contract-First, T5 Tracer Bullet, T6 OpenTelemetry |
| 4 | 페르소나 | 4종 정의 | 최종 사용자(김서연), 프로젝트 관리자(박정우), 시스템 관리자(이승호), 개발자(최민지) |
| 5 | 포털 기능 | User Story 9개 | US-P01~P09: 대시보드, 런처, 검색, 알림, 프로필, 설정, 즐겨찾기, 최근접근 |
| 6 | 권한관리 | User Story 9개 | US-A01~A09: SSO, MFA, RBAC, 역할배정, 위임, 요청/승인, 감사로그 |
| 7 | 마스터관리 | User Story 8개 | US-M01~M08: CRUD, 이력관리, 벌크처리, 승인워크플로우, 품질대시보드 |
| 8 | 비기능 | 성능 수치 | API p95 < 200ms, 동시접속 5,000명, 검색 < 100ms |
| 9 | 비기능 | 가용성 | SLA 99.9%, RTO < 30분, RPO < 5분 |
| 10 | 비기능 | 보안 | OWASP Top 10, TLS 1.3, AES-256, Zero Trust, WCAG 2.1 AA |
| 11 | 우선순위 | MoSCoW | Must 12개, Should 9개, Could 7개, Won't 6개 |
| 12 | 로드맵 | 5단계 42주 | Phase 0(4w) → Phase 1(8w) → Phase 2(8w) → Phase 3(10w) → Phase 4(12w) |
| 13 | 리스크 | 8개 식별 | IdP 연동, MF 호환성, 온보딩 저항, 데이터 마이그레이션, 성능, AI 정확도, 보안, 인력 이탈 |
| 14 | AI 원칙 | 사람이 결정 | AI는 추천까지만, 보안 결정은 반드시 사람이 내린다 |
