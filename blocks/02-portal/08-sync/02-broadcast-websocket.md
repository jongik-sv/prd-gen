---
id: sync-broadcast-websocket
category: sync
label: BroadcastChannel + WebSocket
summary: 같은 브라우저 내에서는 BroadcastChannel로 즉시 동기화하고, 다른 기기/브라우저 간에는 WebSocket으로 서버 경유 동기화한다.
pros:
  - 같은 브라우저 내 동기화는 서버 부하 없이 즉시, 크로스 기기 동기화는 WebSocket으로 실시간
  - 교대 근무, 핫데스킹 등 여러 기기에서 동시에 포털을 사용하는 환경 완전 지원
  - 실시간 데이터(설비 모니터링, 알림 등) 서버 푸시 가능
  - P0 알림을 모든 기기에 즉시 전달 가능
cons:
  - WebSocket 서버 인프라 구축·운영 필요 (스케일링, 연결 관리, 장애 복구)
  - 클라이언트 측 연결 관리 로직 복잡 (재연결, 하트비트, 백오프 등)
  - 네트워크 환경에 따라 WebSocket 연결이 불안정할 수 있음 (프록시, 방화벽)
  - 두 가지 동기화 채널(BroadcastChannel + WebSocket)의 메시지 중복 처리 필요
bestFor:
  - 교대 근무/핫데스킹 환경에서 여러 기기로 동시 접근하는 산업 현장
  - P0 긴급 알림을 모든 기기에 실시간으로 전달해야 하는 경우
  - 설비 모니터링 등 서버에서 클라이언트로 실시간 데이터 푸시가 필요한 시스템
---

## 개요

하이브리드 동기화 전략은 두 계층의 통신 채널을 조합한다:

- **BroadcastChannel (로컬 계층)**: 같은 브라우저 내의 탭/창 간 즉시 동기화. 서버를 거치지 않아 지연 없음.
- **WebSocket (원격 계층)**: 서버를 경유하여 다른 기기/브라우저와 실시간 동기화. 서버에서 클라이언트로의 푸시도 가능.

이 두 계층은 **상호 보완적**으로 동작한다. 로컬 이벤트는 BroadcastChannel로 즉시 전파하고, 서버 관련 이벤트(데이터 변경, 알림 등)는 WebSocket으로 수신한 뒤 다시 BroadcastChannel로 로컬 전파한다.

## 아키텍처

```
기기 A (브라우저)
┌─────────────────────────────────────┐
│  Tab 1 ←──┐                        │
│  Tab 2 ←──┤ BroadcastChannel      │
│  Tab 3 ←──┘     │                  │
│                  │                  │
│            WebSocket Client ────────┼──→ WebSocket Server
└─────────────────────────────────────┘         │
                                                │
기기 B (브라우저)                                  │
┌─────────────────────────────────────┐         │
│  Tab 1 ←──┐                        │         │
│  Tab 2 ←──┤ BroadcastChannel      │         │
│            │                        │         │
│            WebSocket Client ────────┼──→──────┘
└─────────────────────────────────────┘
```

### 메시지 흐름 예시: 데이터 수정

1. 기기 A의 Tab 1에서 주문 수정
2. Tab 1 → BroadcastChannel: "ORDER_UPDATED" 전파 → Tab 2, Tab 3 갱신
3. Tab 1 → 서버 API: 수정 요청 → 서버 DB 반영
4. 서버 → WebSocket: "ORDER_UPDATED" 이벤트를 기기 B에 전송
5. 기기 B의 WebSocket Client → BroadcastChannel: 로컬 탭에 전파
6. 기기 B의 Tab 1, Tab 2 갱신

## 이벤트 분류

| 이벤트 | 로컬(BC) | 원격(WS) | 설명 |
|--------|---------|---------|------|
| 토큰 갱신 | O | X | 같은 브라우저 내 토큰만 동기화 |
| 로그아웃 | O | O | 서버에서 세션 무효화 후 모든 기기에 전파 |
| 테마 변경 | O | O | 서버에 설정 저장 + 다른 기기에 전파 |
| 데이터 변경 | O | O | 로컬 즉시 + 서버 API + 다른 기기 전파 |
| 알림 (P0-P1) | O | O | 서버에서 발생 → WebSocket → 로컬 전파 |
| 알림 (P2-P3) | O | O | 서버에서 발생 → WebSocket → 로컬 전파 |
| 실시간 데이터 | X | O | 서버에서 주기적으로 WebSocket 푸시 |

## WebSocket 연결 관리

### 연결 생명주기

```
포털 로딩
  └── WebSocket 연결 시도
       ├── 성공 → 인증 토큰 전송 → 구독 채널 등록
       │
       └── 실패 → 재연결 (지수 백오프)
            ├── 1초 후 재시도
            ├── 2초 후 재시도
            ├── 4초 후 재시도
            └── 최대 30초 간격으로 반복
```

### 핵심 관리 요소

| 요소 | 설명 |
|------|------|
| 하트비트 | 30초 간격으로 ping/pong 교환, 연결 생존 확인 |
| 재연결 | 연결 끊김 시 지수 백오프(Exponential Backoff)로 재연결 |
| 인증 | 초기 연결 시 JWT 토큰 전송, 토큰 갱신 시 재인증 |
| 구독 | 사용자가 열어둔 앱/데이터에 관련된 채널만 구독 (불필요한 메시지 최소화) |
| 버퍼링 | 일시적 연결 끊김 시 미전달 메시지를 서버에서 버퍼링 후 재연결 시 전달 |

## 메시지 중복 제거

BroadcastChannel과 WebSocket을 동시에 사용하면, 같은 이벤트가 두 경로로 도착할 수 있다. 이를 방지하기 위해:

- 모든 메시지에 고유 ID를 부여
- 수신 측에서 최근 N개의 메시지 ID를 캐시하여 중복 메시지 무시
- 로컬에서 발생한 이벤트는 BroadcastChannel로만 전파하고, WebSocket에서 수신한 동일 이벤트는 무시

## WebSocket 서버 스케일링

사용자 수가 많아지면 WebSocket 서버의 동시 연결 관리가 중요하다:

| 전략 | 설명 |
|------|------|
| 수평 스케일링 | 여러 WebSocket 서버 인스턴스 + Redis Pub/Sub으로 메시지 동기화 |
| 연결 제한 | 사용자당 최대 연결 수 제한 (기기별 1연결) |
| 채널 기반 구독 | 사용자가 관심있는 데이터만 구독하여 불필요한 메시지 최소화 |
| 폴백 | WebSocket 연결 불가 시 SSE 또는 롱 폴링으로 폴백 |

## 제약 사항 및 고려사항

1. **인프라 비용**: WebSocket 서버 운영, Redis 등 메시지 브로커 인프라 필요
2. **방화벽/프록시**: 기업 네트워크에서 WebSocket이 차단될 수 있음 → WSS(TLS) 사용, HTTP 폴백 준비
3. **모바일 배터리**: 모바일에서 WebSocket 상시 연결은 배터리 소모 → 백그라운드 시 연결 해제, 포그라운드 시 재연결
4. **상태 일관성**: 네트워크 지연으로 짧은 시간 동안 기기 간 상태가 다를 수 있음 (Eventually Consistent)
5. **보안**: WebSocket 연결의 인증/인가를 HTTP와 별도로 관리해야 함
