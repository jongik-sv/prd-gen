---
id: sec-2-tier
category: security-isolation
label: 2-tier 격리 (내부/외부 분리)
summary: 내부 앱은 동일 컨텍스트에서 빠르게, 외부 앱은 iframe으로 안전하게 실행하는 2단계 보안 모델.
pros:
  - 내부 앱은 격리 없이 최고 성능, 외부 앱은 iframe으로 최고 보안을 동시에 달성
  - 앱의 신뢰 수준에 따라 합리적으로 자원을 배분하는 실용적 접근
  - 대부분의 앱이 내부 팀 소유라면 성능 영향이 최소화됨
  - 점진적 확장 가능 (처음엔 내부만, 이후 외부 앱 추가)
cons:
  - 내부/외부를 구분하는 기준과 승인 프로세스가 필요
  - 두 가지 통합 경로(직접 마운트 vs iframe)를 모두 구현·유지해야 함
  - 내부 앱이 외부로 전환될 때 (외주 이관 등) 통합 방식 변경 필요
  - 내부 앱 간에는 여전히 격리가 없으므로, 코드 리뷰 프로세스 필수
bestFor:
  - 대부분의 앱이 사내 개발이지만, 일부 외부 벤더 앱도 통합하는 엔터프라이즈 포털
  - 성능과 보안의 균형이 중요한 산업용 시스템 (MES, ERP 등)
  - 내부 팀의 코드 품질 관리가 잘 되어 있는 조직
---

## 개요

2-tier 격리 모델은 앱의 **신뢰 수준(Trust Level)**에 따라 격리 방식을 달리 적용하는 실용적 전략이다. 사내 팀이 개발하고 코드 리뷰·CI/CD를 거친 내부 앱은 같은 JS 컨텍스트에서 빠르게 실행하고, 외부 벤더가 개발했거나 코드 검토가 불가능한 앱은 iframe으로 격리한다.

이 접근의 핵심 원칙은 **"신뢰는 검증을 통해 부여한다"**이다. 무조건 격리하는 것도, 무조건 신뢰하는 것도 아닌, 검증 가능한 앱에만 신뢰를 부여한다.

## 아키텍처

### 신뢰 수준 분류

```
┌─────────────────────────────────────────────────┐
│  Shell App                                       │
│                                                  │
│  ┌─── Tier 1: 신뢰 영역 (Same Context) ───────┐ │
│  │                                              │ │
│  │  [내부 App A]  [내부 App B]  [내부 App C]    │ │
│  │   React/MF      React/MF     React/MF       │ │
│  │                                              │ │
│  │  - 같은 window/document 공유                  │ │
│  │  - 직접 함수 호출 통신                         │ │
│  │  - 디펜던시 공유                               │ │
│  └──────────────────────────────────────────────┘ │
│                                                  │
│  ┌─── Tier 2: 격리 영역 (iframe) ──────────────┐ │
│  │                                              │ │
│  │  ┌──────────┐  ┌──────────┐                  │ │
│  │  │ <iframe> │  │ <iframe> │                  │ │
│  │  │ 외부 App │  │ 레거시   │                  │ │
│  │  │ (벤더 X) │  │ (jQuery) │                  │ │
│  │  └──────────┘  └──────────┘                  │ │
│  │                                              │ │
│  │  - 독립 브라우징 컨텍스트                      │ │
│  │  - postMessage 통신                           │ │
│  │  - sandbox 속성 적용                           │ │
│  └──────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────┘
```

### 신뢰 수준 결정 기준

| 기준 | Tier 1 (신뢰) | Tier 2 (격리) |
|------|--------------|--------------|
| **코드 소유** | 사내 팀이 소스 코드를 소유·관리 | 외부 벤더 개발, 소스 접근 불가 |
| **코드 리뷰** | PR 리뷰 프로세스 적용 | 코드 리뷰 불가 |
| **CI/CD** | 사내 파이프라인에서 빌드·보안 스캔 | 외부 빌드 결과물만 수령 |
| **의존성 관리** | npm audit, Snyk 등 자동 취약점 검사 | 의존성 목록 불투명 |
| **업데이트 통제** | 배포 일정을 사내에서 통제 | 벤더 일정에 의존 |

### manifest에 신뢰 수준 명시

앱의 manifest에는 trustLevel 필드를 포함하여 신뢰 수준을 선언한다. 내부 앱의 경우 trustLevel을 "internal"로, loadStrategy를 "module-federation"으로 설정하고, entry에 사내 CDN의 remoteEntry.js URL을 지정한다. 외부 앱의 경우 trustLevel을 "external"로, loadStrategy를 "iframe"으로 설정하며, entry에 외부 벤더 URL을 지정한다. 외부 앱에는 추가로 iframeOptions를 포함하여 sandbox 속성(예: "allow-scripts allow-same-origin allow-forms")과 allowedOrigin(예: 벤더의 도메인)을 명시한다.

## Tier 1: 내부 앱 보안 조치

격리가 없으므로 프로세스 기반 보안이 필수다:

| 조치 | 구현 방법 | 자동화 여부 |
|------|----------|-----------|
| CSP 헤더 | Nginx/CDN에서 설정 | 자동 |
| ESLint 보안 규칙 | `eslint-plugin-security` 적용 | 자동 |
| 의존성 취약점 스캔 | CI에서 `npm audit --audit-level=high` | 자동 |
| 코드 리뷰 | PR 승인 필수 (최소 1명 시니어) | 수동 |
| CSS 스코핑 | CSS Modules 또는 CSS-in-JS 강제 | 자동 (린팅) |
| 전역 변수 금지 | ESLint `no-restricted-globals` | 자동 |

## Tier 2: 외부 앱 격리 조치

| 조치 | 구현 방법 |
|------|----------|
| iframe sandbox | `allow-scripts allow-same-origin allow-forms` |
| 출처 검증 | postMessage 수신 시 `event.origin` 검사 |
| 토큰 최소 노출 | 필요한 최소 권한의 scoped token만 전달 |
| 네트워크 제한 | CSP의 `connect-src`로 허용 API 도메인 제한 |
| 스토리지 격리 | 교차 출처 iframe은 스토리지 자동 격리 |

## Tier 간 통신

Tier 1 앱 간에는 직접 통신이 가능하지만, Tier 2 앱과의 통신은 Shell을 통해야 한다:

```
Tier 1 App A ←── 직접 이벤트 버스 ──→ Tier 1 App B
     │                                      │
     └──── Shell Event Bus ────┐    ┌───────┘
                                │    │
                          Shell Message Router
                                │    │
                    ┌───────────┘    └──────────┐
                    ↓ postMessage          postMessage ↓
              [iframe: Tier 2 App C]    [iframe: Tier 2 App D]
```

Shell이 **메시지 브로커** 역할을 하여, Tier 1 앱의 이벤트를 Tier 2 앱의 postMessage로 변환하고, 그 역도 수행한다.

## 승인 프로세스

새로운 앱의 Tier 결정 프로세스:

1. **앱 등록 요청**: manifest 제출 (앱 ID, 소유팀, 프레임워크, 출처)
2. **보안 심사**: 코드 소유 여부, CI/CD 파이프라인 연동 여부, 의존성 투명성 확인
3. **Tier 결정**: 심사 결과에 따라 Tier 1 또는 Tier 2 배정
4. **정기 재심사**: 6개월마다 Tier 재검토 (외주 이관, 벤더 변경 등 반영)

## 성능 특성

| 항목 | Tier 1 (내부) | Tier 2 (외부) |
|------|-------------|-------------|
| 앱 간 통신 | < 1ms (직접 호출) | 10~50ms (postMessage) |
| 메모리 | 디펜던시 공유로 최소 | iframe당 50~100MB |
| 초기 로딩 | Module Federation 공유 | 독립 번들 전체 로딩 |
| 앱 전환 | 즉각적 (DOM show/hide) | iframe 생성/로딩 필요 |

## 제약 사항 및 고려사항

1. **경계 관리**: 내부/외부 구분이 명확하지 않은 경우가 있음 (예: 사내 자회사 개발, 퇴사자 코드 등)
2. **이중 인프라**: Tier 1용 직접 통합과 Tier 2용 iframe 통합을 모두 구현·유지해야 함
3. **Tier 변경 비용**: 앱의 Tier가 변경되면 통합 방식을 전환해야 하므로, 전환 비용 발생
4. **일관성**: 같은 포털 내에서 앱마다 다른 통신 패턴을 사용하므로, 개발 가이드 문서화 필요
